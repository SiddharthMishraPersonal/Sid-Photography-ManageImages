<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BeckmanCoulter.Silas</name>
    </assembly>
    <members>
        <member name="T:BeckmanCoulter.Silas.IKeeperService">
            <summary>
            The IKeeperService provides properties and methods that can be used for reading values from the
            Keeper, writing values to the Keeper, and monitoring changes to the Keeper.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.QueryPath(System.String)">
            <summary>
            Sends a query to the Keeper asking for a list of
            all modules that have the given path.
            </summary>
            <param name="path">The path to search for.  This path should be relative to each module, not the root of the Keeper.</param>
            <returns>The list of modules that have the given path.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.QueryPath(System.String,BeckmanCoulter.Silas.ModuleListQueryLoadState)">
            <summary>
            Sends a query to the Keeper asking for a list of
            all modules that have the given path.  Results
            are further filtered by specifying whether to 
            includes only modules that are loaded or only
            those that are not loaded.
            </summary>
            <param name="path">The path to search for.  This path should be relative to each module, not the root of the Keeper.  If null or empty, the path is ignored and all modules will be returned based on the given load state.</param>
            <param name="loadState">The state that the module must be in to be included in the results.</param>
            <returns>The list of modules that have the given path.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.QueryValue(System.String,System.String)">
            <summary>
            Sends a query to the Keeper asking for a list of
            all modules that have the given value at the
            given path.
            </summary>
            <param name="path">The path to search for, including the name of the value.  This path should be relative to each module, not the root of the Keeper.</param>
            <param name="value">The value that the entry pointed to by the path must have.</param>
            <returns>The list of modules that have the given value at the given path.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.QueryValue(System.String,System.String,BeckmanCoulter.Silas.ModuleListQueryLoadState)">
            <summary>
            Sends a query to the Keeper asking for a list of
            all modules that have the given value at the
            given path.
            </summary>
            <param name="path">The path to search for, including the name of the value.  This path should be relative to each module, not the root of the Keeper.</param>
            <param name="value">The value that the entry pointed to by the path must have.</param>
            <param name="loadState">The state that the module must be in to be included in the results.</param>
            <returns>The list of modules that have the given value at the given path.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.GetChecksum(System.String,System.String)">
            <summary>
            Get the checksum for the given module's sub branch
            </summary>
            <param name="moduleName">The name of the module for which a checksum will be retrieved</param>
            <param name="path">The path under the module's branch for which a checksum will be retrieved (e.g. "Configuration")</param>
            <returns>The calculated checksum</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.GetChecksums(System.String)">
            <summary>
            Retrieve the checksums for all modules in the Keeper
            </summary>
            <param name="path">The path under the modules' branches for which checksums will be retrieved (e.g. "Configuration")</param>
            <returns>The checksums for each module as a dictionary where the key is the module name and the value is the checksum</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.GetBranch(System.String)">
            <summary>
            Get a branch from the Keeper
            </summary>
            <param name="path">The path to the branch that should be retrieved from the Keeper</param>
            <returns>The retrieved branch from the Keeper</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.GetBranch(System.String,System.TimeSpan)">
            <summary>
            Get a branch from the Keeper, timing out if the operation does not complete in the given time
            </summary>
            <param name="path">The path to the branch that should be retrieved from the Keeper</param>
            <param name="timeout">The time to wait for the operation to complete.  A TimeoutException will occur if the branch is not retrieved in this amount of time.</param>
            <returns>The retrieved branch from the Keeper</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.GetValue(System.String)">
            <summary>
            Get a value from the Keeper
            </summary>
            <param name="path">The path to the value that should be returned from the Keeper</param>
            <returns>The retrieved value from the Keeper</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.GetValue(System.String,System.TimeSpan)">
            <summary>
            Get a value from the Keeper, timing out if the operation does not complete in the given time
            </summary>
            <param name="path">The path to the value that should be returned from the Keeper</param>
            <param name="timeout">The time to wait for the operation to complete.  A TimeoutException will occur if the branch is not retrieved in this amount of time.</param>
            <returns>The retrieved value from the Keeper</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.SetBranch(System.String,BeckmanCoulter.Silas.ISilasMessage)">
            <summary>
            Add or update a branch in the Keeper
            </summary>
            <param name="path">The path from the root of the Keeper to where the branch should be saved</param>
            <param name="branch">The branch to be saved</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.SetBranch(System.String,BeckmanCoulter.Silas.ISilasMessage,System.TimeSpan)">
            <summary>
            Add or update a branch in the Keeper, timing out if the operation does not complete in the given time
            </summary>
            <param name="path">The path from the root of the Keeper to where the branch should be saved</param>
            <param name="branch">The branch to be saved</param>
            <param name="timeout">The amount of time to wait for the operation to complete.  A TimeoutException will occur if the branch is not saved in this amount of time.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.SetValue(System.String,System.String)">
            <summary>
            Add or set a value in the Keeper
            </summary>
            <param name="path">The path from the root of the Keeper to where the value should be saved</param>
            <param name="value">The value to be saved</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.IKeeperService.SetValue(System.String,System.String,System.TimeSpan)">
            <summary>
            Add or set a value in the Keeper, timing out if the operation does not complete in the given time
            </summary>
            <param name="path">The path from the root of the Keeper to where the value should be saved</param>
            <param name="value">The value to be saved</param>
            <param name="timeout">The amount of time to wait for the operation to complete.  A TimeoutException will occur if the value is not saved in this amount of time.</param>
        </member>
        <member name="P:BeckmanCoulter.Silas.IKeeperService.Portal">
            <summary>
            The SILAS portal associated with this IKeeperService and used for all interactions with
            the Keeper
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.IKeeperService.Saves">
            <summary>
            The stream of save actions sent to the Keeper
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.IKeeperService.Deletes">
            <summary>
            The stream of delete actions sent to the Keeper
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.IKeeperService.Reads">
            <summary>
            The stream of read actions sent to the Keeper
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.KeeperAction">
            <summary>
            A class that represents a read of data from the Keeper, a saving of data to the Keeper, or a deletion of data from the Keeper
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.KeeperAction.#ctor(BeckmanCoulter.Silas.KeeperAction.ActionType,System.String,System.Object,BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Create a new KeeperAction with the given action type, path, data, and target address.
            </summary>
            <param name="action">The action taken on the Keeper</param>
            <param name="path">The path in the Keeper where the action was taken</param>
            <param name="data">The data used in the action (if applicable)</param>
            <param name="address">The target address of the action</param>
        </member>
        <member name="P:BeckmanCoulter.Silas.KeeperAction.DataType">
            <summary>
            The type of data that the Keeper acted upon (either String or Branch)
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.KeeperAction.Action">
            <summary>
            The type of action taken by the Keeper (Read, Save, or Delete)
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.KeeperAction.Path">
            <summary>
            The path on which the Keeper acted
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.KeeperAction.BranchData">
            <summary>
            If DataType is Branch, the branch that the Keeper used in its action.  For reads
            this will be the branch that was read from the Keeper.  For writes, this will be
            the branch that was written to the Keeper.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.KeeperAction.StringData">
            <summary>
            If DataType if String, the value that the Keeper used in its action.  For reads
            this will be the value that was read from the Keeper.  For writes, this will be
            the value that was written to the Keeper.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.KeeperAction.Address">
            <summary>
            The target address for the Keeper action.  The ToName should always be "Keeper".
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.KeeperAction.ActionType">
            <summary>
            The type of action taken on the Keeper
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.KeeperAction.ActionType.Read">
            <summary>
            Data has been requested from the Keeper
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.KeeperAction.ActionType.Save">
            <summary>
            Data has been saved to the Keeper
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.KeeperAction.ActionType.Delete">
            <summary>
            Data has been deleted from the Keeper
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.KeeperAction.ReturnedType">
            <summary>
            The type of data that was sent, retrieved, or deleted
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.KeeperAction.ReturnedType.String">
            <summary>
            The Keeper acted on a single string value
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.KeeperAction.ReturnedType.Branch">
            <summary>
            The Keeper acted on a branch of data
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.KeeperService.QueryPath(System.String)">
            <summary>
            Sends a query to the Keeper asking for a list of
            all modules that have the given path.
            </summary>
            <param name="path">The path to search for.  This path should be relative to each module, not the root of the Keeper.</param>
            <returns>The list of modules that have the given path.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.KeeperService.QueryPath(System.String,BeckmanCoulter.Silas.ModuleListQueryLoadState)">
            <summary>
            Sends a query to the Keeper asking for a list of
            all modules that have the given path.  Results
            are further filtered by specifying whether to 
            includes only modules that are loaded or only
            those that are not loaded.
            </summary>
            <param name="path">The path to search for.  This path should be relative to each module, not the root of the Keeper.  If null or empty, the path is ignored and all modules will be returned based on the given load state.</param>
            <param name="loadState">The state that the module must be in to be included in the results.</param>
            <returns>The list of modules that have the given path.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.KeeperService.QueryValue(System.String,System.String)">
            <summary>
            Sends a query to the Keeper asking for a list of
            all modules that have the given value at the
            given path.
            </summary>
            <param name="path">The path to search for, including the name of the value.  This path should be relative to each module, not the root of the Keeper.</param>
            <param name="value">The value that the entry pointed to by the path must have.</param>
            <returns>The list of modules that have the given value at the given path.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.KeeperService.QueryValue(System.String,System.String,BeckmanCoulter.Silas.ModuleListQueryLoadState)">
            <summary>
            Sends a query to the Keeper asking for a list of
            all modules that have the given value at the
            given path.
            </summary>
            <param name="path">The path to search for, including the name of the value.  This path should be relative to each module, not the root of the Keeper.</param>
            <param name="value">The value that the entry pointed to by the path must have.</param>
            <param name="loadState">The state that the module must be in to be included in the results.</param>
            <returns>The list of modules that have the given value at the given path.</returns>
        </member>
        <member name="T:BeckmanCoulter.Silas.MessageContextGenericWrapper`2">
            <summary>
            The MessageContextGenericWrapper class is used to wrap an existing
            MessageContext object, converting the original ISilasMessage into
            the given type.  Calls to any members other than the Message property
            and the To method simply delegate to the original MessageContext object.
            </summary>
            <typeparam name="TMessage">The type implementing ISilasMessage that this wrapper will provide.</typeparam>
            <typeparam name="TOriginal">The type implementing ISilasMessage that is held by the original MessageContext.</typeparam>
        </member>
        <member name="T:BeckmanCoulter.Silas.IMessageContext`1">
            <summary>
            The IMessageContext interface defines an object that holds
            information relevant to a SILAS message being being transported
            (either to or from the ISilasPortal associated with the
            message context).
            </summary>
            <typeparam name="TMessage"></typeparam>
        </member>
        <member name="M:BeckmanCoulter.Silas.IMessageContext`1.Reply(BeckmanCoulter.Silas.ISilasMessage)">
            <summary>
            Send a reply back to the originator of the message in this IMessageContext.
            If the message attached to this context was already a reply, an exception
            will be thrown.
            </summary>
            <param name="reply">The message that will be sent as a reply to the message attached to this context.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.IMessageContext`1.To``1">
            <summary>
            Create a new message context with the same data as this one but converting
            the current Message to the given type.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:BeckmanCoulter.Silas.IMessageContext`1.RequestId">
            <summary>
            A unique ID for this message (if available).  When replying, this ID will
            be attached to the reply message, allowing the caller to reliably associate
            the reply with the original message.  If there is no ID on the message, this
            will be Guid.Empty.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.IMessageContext`1.Address">
            <summary>
            The address the SILAS Kernel used when sending the attached message.  Keep in mind
            that the "From" name may be spoofed.  Also, there is no guarantee that this
            address will match any %Address branch on the message.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.IMessageContext`1.TimeStamp">
            <summary>
            The date/time that the attached SILAS message was received or sent.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.IMessageContext`1.RawMessage">
            <summary>
            The attached SILAS message serialized in BRC format.  May have a length
            of 0 for certain message types (e.g. "Module Registered").
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.IMessageContext`1.Message">
            <summary>
            The message that was received or is being sent.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.IMessageContext`1.Portal">
            <summary>
            The SILAS portal through which the message was received.  This portal
            will also be used if a reply is sent.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.IMessageContext`1.WasReplySent">
            <summary>
            True if this context has already been used to send a reply.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ActionConfigMessage">
            <summary>
            Default implementation of an Action Config SILAS message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.AddressedMessage">
            <summary>
            Base class for any message types that include an Address branch
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.SilasMessage">
            <summary>
            The default implementation of ISilasMessage
            </summary>
            <remarks>
            <para>
            The SilasMessage class is used to store and manipulate SILAS messages and branches.  By itself,
            the SilasMessage class can be used to directly read and write items to the message by using the 
            Messages and Values dictionaries.  When a developer wishes to work with more strongly typed data,
            the SilasMessage class can be used as a base class and the available mapping methods can be used
            to pull data from the underlying SILAS message into typed properties and/or fields as well as
            push data back to the underlying message.
            </para>
            <example>
            <para>
            Below is an example of a class that derives from SilasMessage and uses the mapping methods to
            ensure that data from the class' properties is synchronized with the Values dictionary.
            </para>
            <code lang="C#">
            public class SampleMessage : SilasMessage
            {
            	public string ComPort { get; set; }
            	public int Retries { get; set; }
            
            	public SampleMessage()
            	{
            		this.MapString(m => m.ComPort);
            		this.MapInt(m => m.Retries, 3);
            	}
            }
            </code>
            </example>
            <para>
            All of the type specific mapping methods (e.g. MapInt, MapBool, etc.) are extension methods that
            exist in the BeckmanCoulter.Silas.  If the available type specific mapping methods do not fit
            your data, the MapMessage and MapValue methods can be used to map any data with given converter
            delegates.
            </para>
            <para>
            Finally, SilasMessage objects can be treated as .NET 4 "dynamics".  This allows you to get or
            set values on the object as if .NET properties or fields existed.
            </para>
            <code>
            dynamic cmdParams = new SilasMessage();
            cmdParams.ProtocolName = "Protocol1";
            dynamic command = new SilasMessage();
            command.CommandName = "Run Protocol";
            command.Parameters = cmdParams;
            </code>
            </remarks>
        </member>
        <member name="T:BeckmanCoulter.Silas.ISilasMessage">
            <summary>
            The ISilasMessage interface defines the members needed by
            any class that wishes to be used as part of SILAS communications.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasMessage.To``1">
            <summary>
            Returns the current ISilasMessage as an instance of the given type.
            If the current ISilasMessage's type has TMessage in its inheritance
            chain already, then it will just return the current ISilasMessage.
            If it doesn't have TMessage in its inheritance chain, then it will
            create a new instance of TMessage and then populate it with the
            messages and values from the current ISilasMessage before returning
            the TMessage.
            </summary>
            <typeparam name="TMessage">The desired SILAS message type. This type must have a parameterless constructor.</typeparam>
            <returns>An ISilasMessage of type TMessage containing the messages and values of the current ISilasMessage.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasMessage.Merge(BeckmanCoulter.Silas.ISilasMessage)">
            <summary>
            Take the given SILAS message and merge its contents with this one.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasMessage.Load(BeckmanCoulter.Silas.ISilasMessage)">
            <summary>
            Load the messages and values from the given source message
            into the current ISilasMessage.  By default, this method will not make
            copies of any messages.  In other words, this ISilasMessage
            will reference the same instances of ISilasMessages that
            the source message does.  Derived message classes may have their
            own policies, however.
            </summary>
            <param name="sourceMessage">The ISilasMessage containing the messages and values that should be loaded into this current ISilasMessage.</param>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasMessage.Messages">
            <summary>
            The collection of sub-messages this message holds.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasMessage.Values">
            <summary>
            The collection of values this message holds.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.#ctor">
            <summary>
            Create a new empty SILAS message.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.Unmap(System.String)">
            <summary>
            Remove all mappings that use the given key
            </summary>
            <param name="key">The key that will be unmapped</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.To``1">
            <summary>
            Returns the current SilasMessage as an instance of the given type.
            If the current SilasMessage's type has TMessage in its inheritance
            chain already, then it will just return the current SilasMessage.
            If it doesn't have TMessage in its inheritance chain, then it will
            create a new instance of TMessage and then populate it with the
            messages and values from the current SilasMessage before returning
            the TMessage.
            </summary>
            <typeparam name="TMessage">The desired SilasMessage type.</typeparam>
            <returns>A SilasMessage of type TMessage containing the messages and values of the current SilasMessage.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.Load(BeckmanCoulter.Silas.ISilasMessage)">
            <summary>
            Load the messages and values from the given source message
            into the current SilasMessage.  By default, this method will not make
            copies of any messages.  In other words, this SilasMessage
            will reference the same instances of SilasMessages that
            the source message does.  Derived message classes may have their
            own policies, however.
            </summary>
            <param name="sourceMessage">The SilasMessage containing the messages and values that should be loaded into this current SilasMessage.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.OnMessageChanged(System.Object,BeckmanCoulter.Silas.Collections.KeyValuePairChangedEventArgs{System.String,BeckmanCoulter.Silas.ISilasMessage})">
            <summary>
            Called whenever the Messages dictionary has an item changed.  The base implementation
            is responsible for pushing the new message to any mapped properties/fields.
            </summary>
            <param name="sender">The source of the event (the Messages ObservableDictionary)</param>
            <param name="keyValuePairChangedEventArgs">The dictionary key/value pair that holds the changed entry</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.OnValueChanged(System.Object,BeckmanCoulter.Silas.Collections.KeyValuePairChangedEventArgs{System.String,System.String})">
            <summary>
            Called whenever the Values dictionary has an item changed.  The base implementation
            is responsible for pushing the new value to any mapped properties/fields.
            </summary>
            <param name="sender">The source of the event (the Values ObservableDictionary)</param>
            <param name="keyValuePairChangedEventArgs">The dictionary key/value pair that holds the changed entry</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.OnMessageBeingAccessed(System.Object,BeckmanCoulter.Silas.Collections.EntryBeingAccessedArgs{System.String,BeckmanCoulter.Silas.ISilasMessage})">
            <summary>
            Called whenever an entry is being accessed from the Messages dictionary.  The
            base implementation is responsible for pushing mapped property/field values
            to the dictionary.
            </summary>
            <param name="sender">The source of the event (the Messages ObservableDictionary)</param>
            <param name="e">The arguments of the event, including the key of the entry being accessed and its current value</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.OnValueBeingAccessed(System.Object,BeckmanCoulter.Silas.Collections.EntryBeingAccessedArgs{System.String,System.String})">
            <summary>
            Called whenever an entry is being accessed from the Values dictionary.  The
            base implementation is responsible for pushing mapped property/field values
            to the dictionary.
            </summary>
            <param name="sender">The source of the event (the Values ObservableDictionary)</param>
            <param name="e">The arguments of the event, including the key of the entry being accessed and its current value</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.OnMessageCollectionBeingAccessed(System.Object,System.EventArgs)">
            <summary>
            Called whenever the Messages dictionary is attempting to provide information
            about the entire dictionary.  The base implementation is responsible for pushing
            mapped property/field values to the dictionary.
            </summary>
            <param name="sender">The source of the event (the Messages ObservableDictionary)</param>
            <param name="e">The arguments of the event</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.OnValueCollectionBeingAccessed(System.Object,System.EventArgs)">
            <summary>
            Called whenever the Values dictionary is attempting to provide information
            about the entire dictionary.  The base implementation is responsible for pushing
            mapped property/field values to the dictionary.
            </summary>
            <param name="sender">The source of the event (the Values ObservableDictionary)</param>
            <param name="e">The arguments of the event</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.SuspendMessageUpdates">
            <summary>
            Suspend synchronization of data in the Messages dictionary with mapped
            members.  Call this before performing bulk operations on the Messages
            dictionary to reduce unnecessary synchronization CPU time.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.ResumeMessageUpdates">
            <summary>
            Resume synchronization of data in the Messages dictionary with mapped
            members.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.SuspendValueUpdates">
            <summary>
            Suspend synchronization of data in the Values dictionary with mapped
            members.  Call this before performing bulk operations on the Values
            dictionary to reduce unnecessary synchronization CPU time.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.ResumeValueUpdates">
            <summary>
            Resume synchronization of data in the Values dictionary with mapped
            members.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.PushMessageToMembers(System.String)">
            <summary>
            Find the entry with the given key in the Messages dictionary and, if it has mappings,
            update the mapped properties/fields with the dictionary entry's current value.  This 
            process will work regardless of whether message updates have been suspended using
            SuspendMessageUpdates.
            </summary>
            <param name="key">The key of the dictionary entry to be pushed</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.PushValueToMembers(System.String)">
            <summary>
            Find the entry with the given key in the Values dictionary and, if it has mappings,
            update the mapped properties/fields with the dictionary entry's current value.  This
            process will work regardless of whether value updates have been suspended using
            SuspendValueUpdates.
            </summary>
            <param name="key">The key of the dictionary entry to be pushed</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.PushMessagesToMembers">
            <summary>
            Find all entries in the Messages dictionary with mappings and update the mapped
            properties/fields with the dictionary entries' current values.  This 
            process will work regardless of whether message updates have been suspended using
            SuspendMessageUpdates.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.PushValuesToMembers">
            <summary>
            Find all entries in the Values dictionary with mappings and update the mapped
            properties/fields with the dictionary entries' current values.  This 
            process will work regardless of whether value updates have been suspended using
            SuspendValueUpdates.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.PushMemberToMessage(System.String)">
            <summary>
            Find the entry with the given key in the Messages dictionary and, if it has mappings,
            update the dictionary with the mapped property's/field's current value.  If more than
            one property/field is mapped to the key, the one that was mapped last will be used.  
            This process will work regardless of whether value updates have been suspended using
            SuspendMessageUpdates.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.PushMemberToValue(System.String)">
            Find the entry with the given key in the Values dictionary and, if it has mappings,
            update the dictionary with the mapped property's/field's current value.  If more than
            one property/field is mapped to the key, the one that was mapped last will be used.  
            This process will work regardless of whether value updates have been suspended using
            SuspendValueUpdates.
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.PushMembersToMessages">
            <summary>
            Find all entries in the Messages dictionary with mappings and update the dictionary
            with the mapped property's/field's current values.  If more than one property/field
            is mapped to a key, the one that was mapped last is used.  This process will work 
            regardless of whether value updates have been suspended using SuspendMessageUpdates.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.PushMembersToValues">
            <summary>
            Find all entries in the Values dictionary with mappings and update the dictionary
            with the mapped property's/field's current values.  If more than one property/field
            is mapped to a key, the one that was mapped last is used.  This process will work 
            regardless of whether value updates have been suspended using SuspendValueUpdates.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.GetMessage(System.String)">
            <summary>
            Return the message in this SilasMessage that has
            the given key.
            </summary>
            <param name="key">The key of the message to return.</param>
            <returns>The message with the given key or null if the message wasn't found.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.GetMessage``1(System.String)">
            <summary>
            Return the message in this SilasMessage that has
            the given key and is of the specified type.
            </summary>
            <typeparam name="TMessage">The type that the message should be or should have in its inheritance chain.</typeparam>
            <param name="key">The key of the message to return.</param>
            <returns>The message with the given key that's of the specified type or null if the message couldn't be found or couldn't be assigned to the given type.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.GetValue(System.String)">
            <summary>
            Return the string value in this SilasMessage that has
            the given key.
            </summary>
            <param name="key">The key of the value to be returned.</param>
            <returns>The value with the given key or null if the key wasn't found.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.GetByKey(System.String)">
            <summary>
            Find a message or value with the given key in the current SilasMessage
            (submessages are not searched).  If there is a message as well as a value
            with the given key, this method will return the message.
            </summary>
            <param name="key">The key of the message or value to be returned.</param>
            <returns>The message or value in this SilasMessage with the given key or null if neither was found.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessage.GetByKey(System.String,System.Boolean)">
            <summary>
            Find a message or value with the given key in the current SilasMessage
            (submessages are not searched).  If there is a message as well as a value
            with the given key, this method will return the message.
            </summary>
            <param name="key">The key of the message or value to be returned.</param>
            <param name="ignoreCase">If true, perform a case insensitive search.</param>
            <returns>The message or value in this SilasMessage with the given key or null if neither was found.</returns>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IAddressedMessage">
            <summary>
            A base interface for any messages that include an Address branch
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IAddressedMessage.Address">
            <summary>
            The address to which the message was or is being sent
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.AddressedMessage.#ctor">
            <summary>
            Create a default addressed message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IActionConfigMessage">
            <summary>
            This message requests that a module perform configuration of an action.  This may involve bringing up a dialog that allows the user to specify an action involving the module.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IDialogMessage">
            <summary>
            A base interface for dialog messages
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDialogMessage.BringToFront">
            <summary>
            One of [True, False]  If this key exists, the dialog is to be brought to the front of all other windows; the value of the key is ignored.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDialogMessage.Location">
            <summary>
            A string identifying where to display the dialog; depending on the value of the string, there may be a matching sub-message (key=Location):
            UpperLeft    	- sub-keys of X and Y under the sub-message "Location"
            Centered			- no sub-keys
            Default				- no sub-keys
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDialogMessage.Coordinates">
            <summary>
            Coordinates that should be applied to the dialog when Location is set to UpperLeft
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigMessage.Command">
            <summary>
            A command message describing the action to be taken. 
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigMessage.ModuleParameter">
            <summary>
            A parameter that indicates which of several “virtual modules” this module is to represent.  Used for modules that control several devices.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigMessage.IsVisible">
            <summary>
            One of [True, False]  If True, the dialog will be shown.  If it is False, the dialog will not be shown.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigMessage.IsManualControlOnly">
            <summary>
            True if the action config is to be used for manual control
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigMessage.TagsMessage">
            <summary>
            Additional information about the message or the sender of the message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ActionConfigMessage.#ctor">
            <summary>
            Create a default Action Config SILAS message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ActionConfigReplyMessage">
            <summary>
            Default implementation of an Action Config Reply message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IActionConfigReplyMessage">
            <summary>
            This message is sent in response to an Action Config Dialog message.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigReplyMessage.IsSuccessful">
            <summary>
            One of [True, False]  False if the module failed to configure (not when the user hits cancel), otherwise True
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigReplyMessage.IsChanged">
            <summary>
            One of [True, False].  True if the configuration changed.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigReplyMessage.Command">
            <summary>
            The Command message that will produce the configured action
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigReplyMessage.Time">
            <summary>
            The time required for the command, given in seconds.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigReplyMessage.ActionDescription">
            <summary>
            The human readable description of the configured action.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigReplyMessage.ErrorText">
            <summary>
            Error description aimed at a user.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigReplyMessage.TouchCount">
            <summary>
            If 0, the command only touches one transport (the first one given in the command), and the touch message is given under “Touch”.
            If >0, the command touches one or more transports or some transport other than the first one.  Touch is a sub-message, under which are sub-messages numbered from 1 to n describing each touch where n is the number given in Touch Count.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IActionConfigReplyMessage.Touch">
            <summary>
            If Touch Count is greater than one, this is a sub-message with entries for each touch message to be produced from the command.  The keys are 1 to n, where n is the total number of touches.  Under each number is a Transport entry with the index of the transport affected (these transport indices correspond to the order that transports are given when the command is eventually sent).  Also under each number is a Touch entry that gives the touch message.
            If Touch Count is 0, this is the touch message affecting the first transport listed in the command message.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ActionConfigReplyMessage.#ctor">
            <summary>
            Create a default Action Config Reply message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage">
            <summary>
            The ReplaceParametersMessage class can be used to represent the Replace
            branch on a command message being returned from a module's Action Config
            window.  Parameters added to this message are used by SAMI to provide 
            run-time data to SILAS modules.
            </summary>
            <remarks>
            Below is an example of creating a command message with replacement parameters
            that will tell SAMI to push the "barcode" labware property as well as all
            labware classes for incoming labware.
            <example>
            <code>
            var command = new CommandMessage("RunProtocol")
                          {
                            Replace = new ReplaceParametersMessage()
                                        {
                                          ReplaceParametersMessage.CreateProperty(parameterName: "Barcode", propertyName: "barcode"),
                                          ReplaceParametersMessage.CreateLabwareClasses("LabwareClasses")
                                        }
                          };
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateOpenForGet(System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns whether the
            current command is opening the device to get the labware (True) or 
            opening the device to put a piece of labware in/on it (False).
            This is only valid on Open and Close commands.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateOpenForPipetting(System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns whether the
            current command is opening the device in order to pipette to/from 
            it (True) or not (False).  This is only valid on Open and Close
            commands.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreatePositionName(System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the name of
            the position from which the labware is coming.  This is only
            valid on Open and Close commands.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateDuration(System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the expected
            duration of the command.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateSourcePosition(System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the source
            position for the movement of a piece of labware.  This is only
            valid for Prepare, Get, Move, and Put commands.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateDestinationPosition(System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the destination
            position for the movement of a piece of labware.  This is only
            valid for Prepare, Get, Move, and Put commands.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateGrip(System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the grip to
            use when moving a piece of labware.  This is only valid for
            Prepare, Get, Move, and Put commands.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateTransportName(System.String,System.String,System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the labware/transport
            name(s).
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <param name="deviceSlot">The slot of the device node (in the SAMI editor) that has the labware to be processed.  If null, all labware sent to the node will be processed.</param>
            <param name="stackIndex">The index of the piece of labware to be processed from the stack assigned to the device slot. The index is one based.  If the device slot parameter is null or whitespace, then this parameters must also be null or whitespace.</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateTransportId(System.String,System.String,System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the labware/transport
            IDs.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <param name="deviceSlot">The slot of the device node (in the SAMI editor) that has the labware to be processed.  If null, all labware sent to the node will be processed.</param>
            <param name="stackIndex">The index of the piece of labware to be processed from the stack assigned to the device slot. The index is one based.  If the device slot parameter is null or whitespace, then this parameters must also be null or whitespace.</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateProperty(System.String,System.String,System.String,System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the given 
            labware/well property.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <param name="propertyName">The name of the labware/well property to be returned</param>
            <param name="deviceSlot">The slot of the device node (in the SAMI editor) that has the labware to be processed.  If null, all labware sent to the node will be processed.</param>
            <param name="stackIndex">The index of the piece of labware to be processed from the stack assigned to the device slot. The index is one based.  If the device slot parameter is null or whitespace, then this parameters must also be null or whitespace.</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateAllLabwareProperties(System.String,System.String,System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns all of the
            labware properties.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <param name="deviceSlot">The slot of the device node (in the SAMI editor) that has the labware to be processed.  If null, all labware sent to the node will be processed.</param>
            <param name="stackIndex">The index of the piece of labware to be processed from the stack assigned to the device slot. The index is one based.  If the device slot parameter is null or whitespace, then this parameters must also be null or whitespace.</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateAllWellProperties(System.String,System.String,System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns all of the
            well properties.
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <param name="deviceSlot">The slot of the device node (in the SAMI editor) that has the labware to be processed.  If null, all labware sent to the node will be processed.</param>
            <param name="stackIndex">The index of the piece of labware to be processed from the stack assigned to the device slot. The index is one based.  If the device slot parameter is null or whitespace, then this parameters must also be null or whitespace.</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateLabwareClassProperty(System.String,System.String,System.String,System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the given
            labware class property (e.g. a property assigned to all BCFlat96
            labware).
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <param name="propertyName"></param>
            <param name="deviceSlot">The slot of the device node (in the SAMI editor) that has the labware to be processed.  If null, all labware sent to the node will be processed.</param>
            <param name="stackIndex">The index of the piece of labware to be processed from the stack assigned to the device slot. The index is one based.  If the device slot parameter is null or whitespace, then this parameters must also be null or whitespace.</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateLabwareTypes(System.String,System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the labware type(s)
            (e.g. TipBox).
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <param name="deviceSlot">The slot of the device node (in the SAMI editor) that has the labware to be processed.  If null, all labware sent to the node will be processed.</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.CreateLabwareClasses(System.String,System.String)">
            <summary>
            Create a KeyValuePair with the given parameterName as the key and
            a value equal to the Scheme expression that returns the labware
            class(es) (e.g. BCFlat96)
            </summary>
            <param name="parameterName">The name that will be given to the parameter when added to a ReplaceParametersMessage</param>
            <param name="deviceSlot">The slot of the device node (in the SAMI editor) that has the labware to be processed.  If null, all labware sent to the node will be processed.</param>
            <returns>The KeyValuePair that should be added to a ReplaceParametersMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.AddOpenForGet(System.String)">
            <summary>
            Add a replacement parameter that will specify whether the
            current command (if it is an Open command) is opening the
            device in order to get labware from it.  If the parameter
            value is false, then the open command is opening the 
            device in order to put a piece of labware in/on it.
            </summary>
            <param name="parameterName">The name of the parameter </param>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.ParametersCollection">
            <summary>
            Convenience property for getting the Parameters dictionary as an
            ICollection of KeyValuePairs.  Since the Dictionary class explicitly
            implements the ICollection&lt;T&gt; interface, you cannot call the
            Add(KeyValuePair&lt;TKey, TValue&gt;) method on it unless you first
            cast it to an ICollection.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ReplaceParametersMessage.Parameters">
            <summary>
            A sub-message with replacement parameters.  The key is the name of the property
            that will be added to the command's Parameters branch by SAMI.  The value is a 
            Scheme expression that SAMI will evaluate and assign to the parameter in the
            Parameters branch.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.PositionHostHotelsMessage.Definitions">
            <summary>
            A collection of PositionHostHotelsDefinitionMessages where
            the key in the Messages dictionary corresponds to the number
            of slots in the hotel.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ResumableErrorMessage">
            <summary> This message is sent by a module to the originator of a command message if an error occurs during the 
            command that could potentially be resumed (or otherwise handled).  The intention is to allow a portion of a high 
            level command to be retried (or otherwise handled) without retrying the whole command.   For example, a single command may 
            require a device go through a number of intermediate steps; if any of those fail and can be retried, this message 
            should be used to allow the originator of the command to decide how to proceed.  Additionally, this message can be 
            used to report spontaneous errors that are not related to a specific command.  See the Command message specification for 
            indicators of when it is allowable to send this message. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ResumableErrorMessage.DefaultMessageType">
            <summary>The default type of this message.</summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ResumableErrorMessage.Error">
            <summary> Describes the error in the form of a Device Error message. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ResumableErrorMessage.Responses">
            <summary> The potential responses (suitable for presentation on a button in a dialog) to the error in a command delimited 
            list.  The response "abort" should not be included; if the controller wishes to abort the command it should do so by 
            sending an Abort message as it normally might. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ResumableErrorMessage.Command">
            <summary> The command that this error is related to; spontaneous errors will leave this key out. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ResumableErrorMessage.Id">
            <summary> Transport ID of the Plate </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ResumableErrorMessage.SoundAlarm">
            <summary> If Sound Alarm? is false, SAMI 4 will not fire the alarm.  This may be used if the module wants to initiate
            error recovery before signaling failure. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ResumableErrorMessage.ResponseCollection">
            <summary>
            The result of splitting the Responses string into the individual response values
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ResumableErrorReplyMessage">
            <summary> This message is sent in reply to a Resumable Error Message. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ResumableErrorReplyMessage.DefaultMessageType">
            <summary>The default type of this message.</summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ResumableErrorReplyMessage.Response">
            <summary> One of the items from the Responses key in the original Resumable Error. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ResumableErrorReplyMessage.Error">
            <summary> A complete copy of the original Resumable Error to allow the module to identify which error the response goes with. </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.CommandReplyMessage">
            <summary>
            Default implementation of the Command Reply SILAS message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.CommandReplyMessage`1">
            <summary>
            Default implementation of the Command Reply SILAS message
            </summary>
            <typeparam name="TParams"></typeparam>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ICommandReplyMessage`1">
            <summary>
            This message is produced by a module when it has completed execution of a Command message.
            </summary>
            <typeparam name="TParams">The type of the custom parameters object of the attached Command message</typeparam>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandReplyMessage`1.IsSuccessful">
            <summary> Indicates whether or not the command completed successfully.</summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandReplyMessage`1.Command">
            <summary> The command this is in reply to. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandReplyMessage`1.ReturnValue">
            <summary> A text string that contains any data that the module is replying with.  For example, if the command were 
            aborted it would be ‘Aborted’. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandReplyMessage`1.Error">
            <summary> If <see cref="P:BeckmanCoulter.Silas.Messages.ICommandReplyMessage`1.IsSuccessful"/> is false, this should contain a description of the error. </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.CommandReplyMessage`1.#ctor">
            <summary>
            Create a default Command Reply SILAS message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ICommandReplyMessage">
            <summary>
            This message is produced by a module when it has completed execution of a Command message.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ConfigurationDialogMessage">
            <summary>
            Default implementation of a Configuration Dialog message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IConfigurationDialogMessage">
            <summary>
            This message requests that a module bring up its configuration dialog.  This dialog should allow the user to configure parameters for the module that are not dependent on what action is currently going on.  For example, modules that control a device serially will have a com port configuration and generally some robot data.  This data is stored by the Keeper (using the Set Module Data message), but the module may format the data any way it wishes.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ConfigurationDialogMessage.#ctor">
            <summary>
            Create a default Configuration Dialog message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ConfigurationDialogReplyMessage">
            <summary>
            Default implementation of a Configuration Dialog Reply message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IConfigurationDialogReplyMessage">
            <summary>
            This message is sent in response to a Configuration Dialog message.  It tells the caller what happened during configuration.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IConfigurationDialogReplyMessage.IsSuccessful">
            <summary>
            One of [True, False]  False if the module failed to configure (not when the user hits cancel), otherwise True
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IConfigurationDialogReplyMessage.IsChanged">
            <summary>
            One of [True, False].  Set to True if the instance configuration for the module changed, otherwise set to False.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IConfigurationDialogReplyMessage.ErrorText">
            <summary>
            Error description aimed at a user.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IConfigurationDialogReplyMessage.ErrorReasons">
            <summary>
            Combination of any of the following that apply:
            Memory — out of memory error while creating dialog
            Registry Broken — Keeper information is missing or incorrect
            Busy — the module is busy with something else, so it cannot put up the dialog
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.ConfigurationDialogReplyMessage.#ctor">
            <summary>
            Create a default Configuration Dialog Reply message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.DeviceDataMessage">
            <summary>
            Default implementation of a Device Data message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IDeviceDataMessage">
            <summary>
            This message is usually sent by a device to report data that it has collected.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.Transport">
            <summary>
            The name of the transport that the data is about.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.DataType">
            <summary>
            The type of data included; one of [Numeric, Text, Boolean]
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.TimeStamp">
            <summary>
            The time/date that the data was taken.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.Count">
            <summary>
            The number of samples that data was taken on
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.StringData">
            <summary>
            The data as a string (if available - check <see cref="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.DataFormat">DataFormat</see>)
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.MessageData">
            <summary>
            The data as a sub message (if available - check <see cref="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.DataFormat">DataFormat</see>).
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.DataFormat">
            <summary>
            One of [Single, By Identifier Index]  If Single, one piece of data as a string in Data; Data is a key.  If By Identifier Index, each sample has a key under Data; Data is a sub-message.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.FormatText">
            <summary>
            A text description of how the data is listed.   Some examples:
            MRI bitmap of the plate
            Wells 1-96 in row major order
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.Description">
            <summary>
            A sub-message that describes the conditions under which the data were taken.  For example, the temperature or wavelength of light used.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceDataMessage.Command">
            <summary>
            The Command message that produced this data (if any)
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.DeviceDataMessage.#ctor">
            <summary>
            Create a default Device Data message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.DeviceDataType">
            <summary>
            The type of the data being sent by a Device Data message
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.DeviceDataType.Numeric">
            <summary>
            Numeric data is being sent
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.DeviceDataType.Text">
            <summary>
            Text data is being sent
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.DeviceDataType.Boolean">
            <summary>
            Boolean data is being sent
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.DeviceDataFormat">
            <summary>
            The format of the data being sent by a Device Data message
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.DeviceDataFormat.Single">
            <summary>
            Only a single value is being sent
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.DeviceDataFormat.ByIdentifierIndex">
            <summary>
            A collection of data is being sent and each item is indexed by its identifier
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.DialogLocationCoordinates">
            <summary>
            The coordinates that should be applied to a dialog
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.DialogLocationCoordinates.#ctor">
            <summary>
            Create a default coordinates message (X = 0, Y = 0)
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.DialogLocationCoordinates.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a coordinates message with the given X and Y values
            </summary>
            <param name="x">The X coordinate of the left edge of the dialog</param>
            <param name="y">The Y coordinate of the top edge of the dialog</param>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.DialogLocationCoordinates.X">
            <summary>
            The X coordinate of the left edge of the dialog
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.DialogLocationCoordinates.Y">
            <summary>
            The Y coordinate of the top edge of the dialog
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.GetModuleDataMessage">
            <summary>
            Default implementation of a Get Module Data message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IGetModuleDataMessage">
            <summary>
            This message requests registry data from the Keeper.  The Keeper replies with a Module Data Reply message.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IGetModuleDataMessage.Path">
            <summary>
            Specifies the path into the registry tree.  This path is much like a path in Windows:  dir\dir\dir\dir
            where dir is the name of a branch  Generally, the first “dir” is the instance name of the module since 
            data is kept on a module by module basis.  The path can specify a branch or leaf node.  If it specifies
            a branch node, all specified branches under that node will be returned.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.GetModuleDataMessage.#ctor">
            <summary>
            Create a default Get Module Data message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.GetModuleDataMessage.#ctor(System.String)">
            <summary>
            Create a Get Module Data message with the given path
            </summary>
            <param name="path">The path to the data </param>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IAbortMessage">
            <summary>
            This message tells a device to stop what it is doing.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IAbortMessage.IsEmergency">
            <summary>
            One of [True, False]  If False, the module should continue to a point where it is safe to stop for an indefinite amount of time.  If True, the module should stop, regardless of other activity.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IAbortMessage.Index">
            <summary> 
            If the device being aborted deals with multiple transports, this key must indicate which part of the 
            device to abort (e.g., one of the four parts of a tetrad).
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IAbortReplyMessage">
            <summary>
            This message is sent in response to an Abort message
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IAbortReplyMessage.IsSuccessful">
            <summary>
            One of [True, False]
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ICommandParametersMessage">
            <summary>
            Parameters to a default Command SILAS message
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandParametersMessage.Time">
            <summary>
            When no hardware is present, this time (in milliseconds) will be used to determine how long to wait before responding to the command (i.e., how long to 'simulate').  If the parameter is not present, the module will estimate the time from the given command.
            When hardware is present, the module will use the maximum of (1) the estimated time for the command (i.e., the one used for simulation timing, see above) and (2) the time found in the command's 'Time' parameter, for device communication timeouts.  On top of this, it should add the amount of time in the ‘Timeout’ key in the Keeper (in milliseconds).
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandParametersMessage.Index">
            <summary>
            This parameter indicates which slot of the device is to be used in a multi-position device.  For instance, in an 'Open' command to a carousel, the 'Index' parameter will be set to the index of the slot to which the carousel should spin.  Indices that are outside the range of the device should be refused (and report a Log Level error, see next section).
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.DialogLocation">
            <summary>
            Locations at which a dialog may be placed
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.DialogLocation.Default">
            <summary>
            The dialog should appear where it wants (centered is a good default).
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.DialogLocation.Centered">
            <summary>
            The dialog should appear centered on the default screen.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.DialogLocation.UpperLeft">
            <summary>
            The message will specify the location of the upper left corner of the dialog under the 
            <see cref="P:BeckmanCoulter.Silas.Messages.IDialogMessage.Coordinates"/> property of the <see cref="T:BeckmanCoulter.Silas.Messages.IDialogMessage"/>.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ErrorReason">
            <summary>
            Possible reasons for an error with the configuration dialog
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorReason.None">
            <summary>
            No error reason was given
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorReason.Memory">
            <summary>
            Out of memory error while creating dialog
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorReason.RegistryBroken">
            <summary>
            Keeper information is missing or incorrect
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorReason.Busy">
            <summary>
            The module is busy with something else, so it cannot put up the dialog
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ILoadFinishedMessage">
            <summary>
            This message is a reply to the Load Module message.  It indicates whether the module instance successfully loaded.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ILoadFinishedMessage.InstanceName">
            <summary>
            The instance name of the module
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ILoadFinishedMessage.IsSuccessful">
            <summary>
            One of [True, False]
            If True, the module was successfully loaded.  If False, an error occurred (and the following two fields will be included).
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ILoadFinishedMessage.Reason">
            <summary>
            Comma delimited list of all of the following that apply:
            Timed Out, Not Found, Not Registered
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ILoadFinishedMessage.ErrorText">
            <summary>
            Error description aimed at the user; should also be appropriate for log files.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ILoadFinishedMessage.ReferenceCount">
            <summary>
            The reference count held by the Keeper for the module.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ILoadModuleMessage">
            <summary>
            This message is usually sent to the Keeper.  The Keeper is responsible for loading the module, verifying it correctly loaded, and replying to this message with results in a Load Finished message.  The Keeper may not actually load the module if it is already running; in this case, the Keeper will simply increment a reference count, to keep track of how many modules expect the requested module to be running.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ILoadModuleMessage.InstanceName">
            <summary>
            The instance name of the module
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IPauseMessage.Index">
            <summary> If the device being aborted deals with multiple transports, this key must indicate which part of the 
            device to abort (e.g., one of the four parts of a tetrad). </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IResumeMessage.Index">
            <summary> If the device being resumed deals with multiple transports, this key must indicate which part of the 
            device to resume (e.g., one of the four parts of a tetrad). </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IStatusMessage">
            <summary>
            This message is sent by a module whenever its status has changed or in reply to a Status Query message.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IStatusMessage.IsUpdate">
            <summary>
            If True, the message is an update; not a full status message, just the changes
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IStatusMessage.CurrentError">
            <summary>
            A sub-message indicating the current error, if there is a current error.  It has the same format as the standard Device Error message.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IStatusMessage.CurrentCommand">
            <summary>
            A sub-message indicating the current command, if there is a current command.  It has the same format as the standard Command message.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IStatusMessage.CurrentCommandProgress">
            <summary>
            A value indicating the percentage of the current command that has been completed.  This is not part of the SILAS specification and
            should not always be expected.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IStatusMessage.CurrentCommandStatus">
            <summary>
            Text describing the status of the currently running command.  This is not part of the SILAS specification and should not
            always be expected.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IStatusMessage.Commands">
            <summary>
            A sub-message that indicates what commands can be sent to the device.  Each of these strings is either True or False, depending on whether we can send it that command at this time.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IStatusMessage.IsBusy">
            <summary>
            One of [True, False]  True if the hardware is busy.  False otherwise.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IStatusMessage.IsHardwareActive">
            <summary>
            One of [True, False]  True if we are touching the hardware yet.  This would be True, for example, if we opened the com port.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IStatusMessage.Approach">
            <summary>
            One of [Open, Closed, Indeterminate]  Open, if the robot’s arm can get in to remove or add a plate.  Closed, if the robot’s arm cannot get in.  Indeterminate, if we do not know.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.StatusApproachType">
            <summary> Kinds of approaches </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.StatusApproachType.Open">
            <summary> The robot can get into the device. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.StatusApproachType.Closed">
            <summary> The robot cannot get into the device. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.StatusApproachType.Indeterminate">
            <summary> We don't know if a robot could enter. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.StatusApproachType.Unknown">
            <summary> Unknown. </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IUnloadMessage">
            <summary>
            This message is usually sent to a module by the Keeper.  It requests that the module unload (and usually then unregister) itself.  The module should reply with an Unload Reply.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IUnloadMessage.Prejudice">
            <summary>
            One of [Extreme, None, Ask User]
            If Extreme, unload regardless of anything else
            If None, unload if possible/reasonable; do not contact the user
            If Ask User, ask the user if the module should unload
            Note: For simplicity, most modules should ignore this parameter and simply unload, regardless of the prejudice level.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IUnloadMessage.ReasonText">
            <summary>
            Reason for unloading; aimed at the user.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.UnloadPrejudice.Extreme">
            <summary>
            Unload regardless of anything else
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.UnloadPrejudice.None">
            <summary>
            Unload if possible/reasonable; do not contact the user
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.UnloadPrejudice.AskUser">
            <summary>
            Ask the user if the module should unload
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IUnloadModuleMessage">
            <summary>
            This message is usually sent to the Keeper in order to unload a currently running module.  The Keeper decrements its reference count on the module and if no references remain, it unloads the module.  The Keeper then sends an Unload Finished message with the results.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IUnloadModuleMessage.InstanceName">
            <summary>
            The instance name of the module
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IUnloadReplyMessage">
            <summary>
            This message is sent in reply to an Unload message.
            Important:  This message is not to be sent until after all SILAS™ communication (such as updating Keeper data) has been completed.  Also, the module should not unregister until after this message has been sent.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IUnloadReplyMessage.IsUnloading">
            <summary>
            One of [True, False]  If True, the module is in the process of unloading and has not unregistered yet.  If False, the module is refusing to unload — interaction with other modules is unpredictable and the Keeper will essentially consider the module to be unloaded anyway.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IUnloadReplyMessage.ReasonText">
            <summary>
            If the above field is False, this gives the reason that the Unload did not occur.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.LoadFinishedMessage">
            <summary>
            Default implementation of a Load Finished message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.LoadFinishedMessage.#ctor">
            <summary>
            Create a default Load Finished message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.LoadModuleMessage">
            <summary>
            Default implementation of a Load Module message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.LoadModuleMessage.#ctor">
            <summary>
            Create a default Load Module message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.LoadModuleMessage.#ctor(System.String)">
            <summary>
            Create a Load Module message with the given module instance name
            </summary>
            <param name="instanceName">The name of the module to load</param>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.SamiCommandMessage">
            <summary>
            A single SAMI command meant to be stored in the Keeper
            under a module's %Class/SAMI4 branch.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.PositionHostCommandsMessage">
            <summary>
            The PositionHostCommandMessage holds commands that are to be stored
            in the Keeper under a module's %Class/SAMI4 branch.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.PositionHostTimingMessage.OpenTime">
            <summary>
            Scheme code that will return the amount of time the Open command is expected to take
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.PositionHostTimingMessage.CloseTime">
            <summary>
            Scheme code that will return the amount of time the Close command is expected to take
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.StartRunMessage`1">
            <summary>
            Message sent to consumer modules when a new run has been started.
            </summary>
            <typeparam name="TRunParams">Parameters for the consumer module, saved during the module's configuration in the SAMI Editor</typeparam>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.StatusMessage">
            <summary>
            Default implementation of a Status SILAS message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.StatusMessage.#ctor">
            <summary>
            Create a new default Status SILAS message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.UnloadMessage">
            <summary>
            Default implementation of an Unload SILAS message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.UnloadMessage.#ctor">
            <summary>
            Create a default Unload SILAS message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.UnloadModuleMessage">
            <summary>
            Default implementation of an Unload Module message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.UnloadModuleMessage.#ctor">
            <summary>
            Create a new default Unload Module message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.UnloadModuleMessage.#ctor(System.String)">
            <summary>
            Create a new Unload Module message with the given instance name
            </summary>
            <param name="instanceName">The name of the module to be unloaded</param>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.UnloadReplyMessage">
            <summary>
            Default implementation of an Unload Reply SILAS message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.UnloadReplyMessage.#ctor">
            <summary>
            Create a default Unload Reply SILAS message
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:BeckmanCoulter.Silas.Collections.KeyPairChangedAction" -->
        <member name="F:BeckmanCoulter.Silas.Collections.KeyPairChangedAction.Add">
            <summary>
            A key pair was added to the observable dictionary
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Collections.KeyPairChangedAction.Remove">
            <summary>
            A key pair was removed from the observable dictionary
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Collections.KeyPairChangedAction.Change">
            <summary>
            The value of a key pair has changed in the observable dictionary
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Collections.KeyValuePairChangedEventArgs`2">
            <summary>
            Arguments that are sent as part of the ObservableDictionary's KeyValuePairChanged
            event.
            </summary>
            <typeparam name="TKey">The type of the keys in the observable dictionary</typeparam>
            <typeparam name="TValue">The type of the values in the observable dictionary</typeparam>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.KeyValuePairChangedEventArgs`2.#ctor(`0,`1,BeckmanCoulter.Silas.Collections.KeyPairChangedAction)">
            <summary>
            Create a new KeyValuePairChangedEventArgs object with the given key, value,
            and action.
            </summary>
            <param name="key">The key of the key pair that was the target of the action</param>
            <param name="value">The value of the key pair that was the target of the action</param>
            <param name="action">The action that has been applied to the key pair</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.KeyValuePairChangedEventArgs`2.#ctor(`0,`1,`1,BeckmanCoulter.Silas.Collections.KeyPairChangedAction)">
            <summary>
            Create a new KeyValuePairChangedEventArgs object with the given key, previous value,
            new value, and action.
            </summary>
            <param name="key">The key of the key pair that was the target of the action</param>
            <param name="value">The current value of the key pair that was the target of the action</param>
            <param name="oldValue">The previous value of the key pair (if applicable) that was the target of the action</param>
            <param name="action"></param>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.KeyValuePairChangedEventArgs`2.Key">
            <summary>
            The key for the key pair that was the target of the action
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.KeyValuePairChangedEventArgs`2.Value">
            <summary>
            The value for the key pair that was the target of the action.
            If the action was "Change", then this holds the new value.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.KeyValuePairChangedEventArgs`2.OldValue">
            <summary>
            If the action was "Change", this will hold the previous value
            of the key pair.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.KeyValuePairChangedEventArgs`2.Action">
            <summary>
            The action that was taken on the key pair
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Collections.KeyValuePairChangedHandler`2">
            <summary>
            A delegate used by the KeyValuePairChanged event of the ObservableDictionary class
            </summary>
            <typeparam name="TKey">The type of the key of the item being changed</typeparam>
            <typeparam name="TValue">The type of the value of the item being changed</typeparam>
            <param name="sender">The originator of the event</param>
            <param name="e">The arguments for the event</param>
        </member>
        <member name="T:BeckmanCoulter.Silas.Collections.EntryBeingAccessedArgs`2">
            <summary>
            Arguments for the ValueBeingAccessed event on the ObservableDictionary.
            </summary>
            <typeparam name="TKey">The type of the keys in the ObservableDictionary</typeparam>
            <typeparam name="TValue">The type of the values in the ObservableDictionary</typeparam>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.EntryBeingAccessedArgs`2.#ctor(`0,`1)">
            <summary>
            Create a new EntryBeingAccessedArgs object with the given key and value
            </summary>
            <param name="key">The key of the key pair being accessed in the ObservableDictionary</param>
            <param name="value">The value of the key pair being accessed in the ObservableDictionary</param>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.EntryBeingAccessedArgs`2.Key">
            <summary>
            The key of the key pair being accessed in the ObservableDictionary
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.EntryBeingAccessedArgs`2.Value">
            <summary>
            The value of the key pair being accessed in the ObservableDictionary
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Collections.ObservableDictionary`2">
            <summary>
            A dictionary that will fire events when key pairs are being accessed, changed, deleted, or added.
            </summary>
            <typeparam name="TKey">The type of the keys in the ObservableDictionary</typeparam>
            <typeparam name="TValue">The type of the values in the ObservableDictionary</typeparam>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.#ctor">
            <summary>
            Create a new empty ObservableDictionary
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Create a new ObservableDictionary that contains the contents of the
            given dictionary
            </summary>
            <param name="copy">The dictionary whose values should be copied into the new dictionary</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.GetEnumerator">
            <summary>
            Get an enumerator that can be used to iterate over key value pairs in the dictionary
            </summary>
            <returns>The IEnumerator that can be used to iterate over the key value pairs in the dictionary</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator that can be used to iterate over key value pairs in the dictionary
            </summary>
            <returns>The IEnumerator that can be used to iterate over the key value pairs in the dictionary</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Add an item to the dictionary with the given key and value
            </summary>
            <param name="item">The KeyValuePair holding the key and value to be added to the dictionary</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Clear">
            <summary>
            Remove all items from the dictionary
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Check if an item exists in the dictionary
            </summary>
            <param name="item">The item to look for in the dictionary</param>
            <returns>True if the item is found, false otherwise</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copy the dictionary to an array of KeyValuePairs
            </summary>
            <param name="array">The array that will hold the dictionary's contents</param>
            <param name="arrayIndex">The index at which to begin copying items into the array</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Remove the given item from the dictionary
            </summary>
            <param name="item">The item to be removed</param>
            <returns>True if the item was removed, false otherwise</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.ContainsKey(`0)">
            <summary>
            Determine if the dictionary has an item with the given key
            </summary>
            <param name="key">The key to look for in the dictionary</param>
            <returns>True if an item with the given key was found, false otherwise</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Add(`0,`1)">
            <summary>
            Add a value to the dictionary with the given key
            </summary>
            <param name="key">The key to be used when adding the value to the dictionary</param>
            <param name="value">The value to be added to the dictionary</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Remove(`0)">
            <summary>
            Remove the item from the dictionary with the given key
            </summary>
            <param name="key">The key of the item to be removed</param>
            <returns>True if the item was removed, false otherwise</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempt to retrieve a value from the dictionary with the given key
            </summary>
            <param name="key">The key of the value to retrieve</param>
            <param name="value">The value retrieved from the dictionary if the operation was successful</param>
            <returns>True if the value was successfully retrieved from the dictionary, false otherwise</returns>
        </member>
        <member name="E:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.CollectionChanged">
            <summary>
            An event that fires whenever the dictionary has items added, removed, or changed
            </summary>
        </member>
        <member name="E:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.PropertyChanged">
            <summary>
            An event that fires whenever a property of the dictionary changes (this does not include properties of items in the dictionary)
            </summary>
        </member>
        <member name="E:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.KeyValuePairChanged">
            <summary>
            An event that fires whenever a key value pair has had some action applied to it (it was added, removed, or changed)
            </summary>
        </member>
        <member name="E:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.ValueBeingAccessed">
            <summary>
            An event that fires before a value on the dictionary is accessed.  This allows listeners to update the dictionary
            or perform other actions before the dictionary's value is returned.
            </summary>
        </member>
        <member name="E:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.CollectionBeingAccessed">
            <summary>
            An event that fires before a property dependent upon the entire dictionary (e.g. Count) is accessed.  This allows
            listeners to update the dictionary or perform other actions before the dictionary's property is returned.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Count">
            <summary>
            The number of items currently in the dictionary
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.IsReadOnly">
            <summary>
            True if the dictionary can only be read.  False if items can be read or written.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Item(`0)">
            <summary>
            Get or set a value in the dictionary using the given key
            </summary>
            <param name="key">The key of the item to get or set</param>
            <returns>The value of with the given key</returns>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Keys">
            <summary>
            All the keys for items currently stored in the dictionary
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Collections.ObservableDictionary`2.Values">
            <summary>
            All the values currently stored in the dictionary
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Utility.Converters">
            <summary>
            Helper methods for converting values to and from strings.  This class is primarily used
            by the SilasMessage class to support various mappings.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToBool(System.String,System.Boolean)">
            <summary>
            Attempt to convert a string to a bool.  If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a bool or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToBool(System.String,System.Nullable{System.Boolean})">
            <summary>
            Attempt to convert a string to a bool.  If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a bool or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.BoolToString(System.Boolean)">
            <summary>
            Convert the given bool to a string
            </summary>
            <param name="b">The bool to be converted</param>
            <returns>The bool converted to a string</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToInt(System.String,System.Int32)">
            <summary>
            Attempt to convert a string to an int.  If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to an int or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToInt(System.String,System.Nullable{System.Int32})">
            <summary>
            Attempt to convert a string to an int.  If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to an int or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.IntToString(System.Int32)">
            <summary>
            Convert the given int to a string
            </summary>
            <param name="i">The int to be converted</param>
            <returns>The int converted to a string</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToLong(System.String,System.Int64)">
            <summary>
            Attempt to convert a string to a long.  If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a long or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToLong(System.String,System.Nullable{System.Int64})">
            <summary>
            Attempt to convert a string to a long.  If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a long or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.LongToString(System.Int64)">
            <summary>
            Convert the given long to a string
            </summary>
            <param name="l">The long to be converted</param>
            <returns>The long converted to a string</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToDouble(System.String,System.Double)">
            <summary>
            Attempt to convert a string to a double.  If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a double or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToDouble(System.String,System.Nullable{System.Double})">
            <summary>
            Attempt to convert a string to a double.  If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a double or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.DoubleToString(System.Double)">
            <summary>
            Convert the given double to a string
            </summary>
            <param name="d">The double to be converted</param>
            <returns>The double converted to a string</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToDecimal(System.String,System.Decimal)">
            <summary>
            Attempt to convert a string to a decimal. If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a decimal or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToDecimal(System.String,System.Nullable{System.Decimal})">
            <summary>
            Attempt to convert a string to a decimal. If the conversion fails, use the given default value.
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a decimal or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.DecimalToString(System.Decimal)">
            <summary>
            Convert the given decimal to a string
            </summary>
            <param name="d">The decimal to be converted</param>
            <returns>The decimal converted to a string</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.DecimalToString(System.Nullable{System.Decimal})">
            <summary>
            Convert the given decimal to a string
            </summary>
            <param name="d">The decimal to be converted</param>
            <returns>The decimal converted to a string</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.NameToEnum``1(System.String,System.Nullable{``0})">
            <summary>
            Attempt to convert a string representing an enum value to the actual enum value
            </summary>
            <typeparam name="TEnum">The enum type</typeparam>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to the enum or the given default if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.NameToEnum``1(System.String,``0)">
            <summary>
            Attempt to convert a string representing an enum value to the actual enum value
            </summary>
            <typeparam name="TEnum">The enum type</typeparam>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to the enum or the given default if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.DescriptionToEnum``1(System.String,``0)">
            <summary>
            Attempt to convert a string representing the description of an enum value to the actual enum value.
            An enum value is given a description by applying the DescriptionAttribute to the enum value.
            </summary>
            <typeparam name="TEnum">The enum type</typeparam>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to the enum or the given default if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.DescriptionToEnum``1(System.String,System.Nullable{``0})">
            <summary>
            Attempt to convert a string representing the description of an enum value to the actual enum value.
            An enum value is given a description by applying the DescriptionAttribute to the enum value.
            </summary>
            <typeparam name="TEnum">The enum type</typeparam>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to the enum or the given default if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.EnumToName``1(``0)">
            <summary>
            Convert an enum value back to its name
            </summary>
            <typeparam name="TEnum">The type of the enum to be converted</typeparam>
            <param name="e">The value of the enum to be converted</param>
            <returns>The name that corresponds to the enum value</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.EnumToDescription``1(``0)">
            <summary>
            Convert an enum value to the enum's description as given by a DescriptionAttribute
            applied to the value in the enum's definition
            </summary>
            <typeparam name="TEnum">The type of the enum to be converted</typeparam>
            <param name="e">The value of the enum to be converted</param>
            <returns>The description that corresponds to the enum value or the name if no description was found</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.DateTimeToString(System.DateTime)">
            <summary>
            Convert a DateTime to its string representation
            </summary>
            <param name="dateTime">The DateTime to be converted</param>
            <returns>The string representation of the given DateTime</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToDateTime(System.String,System.DateTime)">
            <summary>
            Attempt to convert the given string to a DateTime object
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a DateTime or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToDateTime(System.String,System.Nullable{System.DateTime})">
            <summary>
            Attempt to convert the given string to a DateTime object
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a DateTime or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.OleDateTimeToString(System.DateTime)">
            <summary>
            Convert a DateTime to its string representation in OLE date/time format
            </summary>
            <param name="dateTime">The DateTime to be converted</param>
            <returns>The string representation of the given DateTime</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToOleDateTime(System.String,System.DateTime)">
            <summary>
            Attempt to convert the given string with an OLE formatted date/time to a DateTime object
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a DateTime or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToOleDateTime(System.String,System.Nullable{System.DateTime})">
            <summary>
            Attempt to convert the given string with an OLE formatted date/time to a DateTime object
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a DateTime or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.GuidToString(System.Guid)">
            <summary>
            Convert a Guid to its string representation
            </summary>
            <param name="guid">The Guid to be converted</param>
            <returns>The string representation of the given Guid</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToGuid(System.String,System.Guid)">
            <summary>
            Attempt to convert the given string to a Guid object
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a Guid or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToGuid(System.String,System.Nullable{System.Guid})">
            <summary>
            Attempt to convert the given string to a Guid object
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a Guid or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.VersionToString(System.Version)">
            <summary>
            Convert a Version to its string representation
            </summary>
            <param name="version">The Version to be converted</param>
            <returns>The string representation of the given Version or an empty string if the Version object was null</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.StringToVersion(System.String,System.Version)">
            <summary>
            Attempt to convert the given string to a Version object
            </summary>
            <param name="s">The string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string converted to a Version or the given default value if the string could not be converted</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.BytesToBase64(System.Byte[])">
            <summary>
            Convert a given byte array to a base 64 encoded string
            </summary>
            <param name="bytes">The byte array to be encoded</param>
            <returns>A base 64 encoded string of the byte array</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Converters.Base64ToBytes(System.String,System.Byte[])">
            <summary>
            Convert a base 64 encoded string into a byte array
            </summary>
            <param name="s">The base 64 encoded string to be converted</param>
            <param name="defaultValue">The value that will be returned if the string cannot be converted</param>
            <returns>The string base 64 decoded into a byte array</returns>
        </member>
        <member name="T:BeckmanCoulter.Silas.Utility.Locker">
            <summary>
            The Locker class can be used to help simplify code in classes that
            implement IDisposable but are also expected to be thread safe.
            </summary>
            <remarks>
            When creating a class that implements IDisposable that must also be
            thread safe, it is important to ensure that an instance does not
            get disposed on one thread while another is in the middle of running
            a method that uses the resources being disposed.  At the same time,
            it may be unwise to simply perform a lock around the entire body of
            each method that uses these disposable resources since that will
            restrict the instance to being used by only one thread at a time.
            
            Using the Locker class allows you to more easily create classes that
            allow methods to be called by multiple threads simultaneously, but
            ensures that disposal of the object can only occur when all pending
            operations/methods have finished.
            
            In order to use the Locker in this way, create a new instance of
            the Locker.  In each method that uses disposable resources, call
            the Locker's Lock method to get an IDisposable instance.  When
            this IDisposable instance is disposed, you are telling the Locker
            to release your lock.
            
            <example>
            <code>
            public class ThreadSafeDisposable : IDisposable
            {
              private IDisposable _disposableResource;
              private Locker _locker = new Locker("The ThreadSafeDisposable has been disposed.");
            
              public void PerformOperation()
              {
                using(_locker.Lock())
                {
                  // Perform an operation using _disposableResource
                }
              }
            
              public void Dispose()
              {
                _locker.Dispose();
                _disposableResource.Dispose();
              }
            }
            </code>
            </example>
            In the above example, calling _locker.Dispose() waits for all existing
            locks to be released before disposing of the Locker.  Calls made to
            Lock while the Locker is being disposed and after it has been disposed
            will result in an ObjectDisposedException being thrown.
            </remarks>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Locker.#ctor(System.String)">
            <summary>
            Create a new Locker, providing the message that will be used when
            the class throws an ObjectDisposedException.
            </summary>
            <param name="disposedMessage">The message that will be used whenever throwing an ObjectDisposedException</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Locker.Lock">
            <summary>
            Obtain a single lock.  Multiple threads may obtain and hold a lock at the
            same time.  The Locker itself cannot be disposed until the returned IDisposable
            (and all other IDisposables returned from other calls to Lock) has been 
            disposed.
            </summary>
            <returns>An IDisposable instance that, when disposed, releases the lock</returns>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Locker.TryDispose(System.TimeSpan)">
            <summary>
            Attempt to dispose the Locker so that no more locks can
            be taken.  If all locks are not released within the
            given timeout period, the object will not be disposed.
            </summary>
            <param name="timeout">The amount of time to wait for all locks to be released</param>
            <returns>True if the object was successfully disposed.  False otherwise.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Locker.Dispose">
            <summary>
            Dispose the locker.  This method will block until all locks (taken
            using the Lock method) have been released.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Utility.Locker.IsDisposed">
            <summary>
            True if the Locker has been disposed and cannot be used for further locks
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Utility.Locker.LockCount">
            <summary>
            The number of locks that are waiting to be released
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.IMessagePumpProvider.Run">
            <summary>
            Starts the message pump on a new thread and returns immediately.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.IMessagePumpProvider.Shutdown">
            <summary>
            Sends a message to the message pump to shutdown.  The method should not block
            to avoid potential deadlocks.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.IMessagePumpProvider.AddHook(System.Windows.Interop.HwndSourceHook)">
            <summary>
            Provide a delegate that will be called any time a message is received 
            on this pump.
            </summary>
            <param name="hook">The delegate to call whenever a message is received.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.IMessagePumpProvider.DoEvents">
            <summary>
            Process messages that are waiting in the queue.  This may cause re-entry.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.IMessagePumpProvider.Invoke(System.Delegate,System.Object[])">
            <summary>
            Invoke the given delegate on the thread on which the message pump is running.  This
            method will block until the given delegate completes.
            </summary>
            <param name="method">The delegate to be run.</param>
            <param name="args">Any arguments that should be sent to the delegate that will be run.</param>
            <returns>The return value of the delegate, if it has one.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.IMessagePumpProvider.BeginInvoke(System.Delegate,System.Object[])">
            <summary>
            Invoke the given delegate on the thread on which the message pump is running.  This
            method will not block and returns immediately.
            </summary>
            <param name="method">The delegate to be run.</param>
            <param name="args">Any arguments that should be sent to the delegate that will be run.</param>
        </member>
        <member name="P:BeckmanCoulter.Silas.Utility.IMessagePumpProvider.Handle">
            <summary>
            The window handle being used to receive messages with this pump.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Utility.IMessagePumpProvider.ThreadHandle">
            <summary>
            A handle to the thread that is running the message pump.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.NativeMessagePumpProvider.Run">
            <summary>
            Starts the message pump on a new thread and returns immediately.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.NativeMessagePumpProvider.Shutdown">
            <summary>
            Completely stops the message pump.  Call Run to start it back up again.
            All delegates passed to AddHook will remain hooked.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.NativeMessagePumpProvider.AddHook(System.Windows.Interop.HwndSourceHook)">
            <summary>
            Provide a delegate that will be called any time a message is received 
            on this pump.
            </summary>
            <param name="hook">The delegate to call whenever a message is received.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.NativeMessagePumpProvider.DoEvents">
            <summary>
            Process messages that are waiting in the queue.  This may cause re-entry.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Utility.NativeMessagePumpProvider.Handle">
            <summary>
            The window handle being used to receive messages with this pump.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Utility.NativeMessagePumpProvider.Priority">
            <summary>
            The DispatcherPriority that will be used when issuing Invoke and BeginInvoke
            delegates.  Defaults to DispatcherPriority.Normal.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.ExceptionExtensions">
            <summary>
            Extension methods for Exception objects
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.ExceptionExtensions.GenerateStackTrace(System.Exception,System.Text.StringBuilder)">
            <summary>
            Generate a formatted stack trace for the given exception object.
            </summary>
            <param name="exception">The exception that contains the stack trace to be formatted</param>
            <param name="builder">A StringBuilder to be used when formatting the stack trace.  If null, a new one will be created.</param>
            <returns>A string that contains the formatted stack trace (as well as whatever other contents might have been in the provided StringBuilder)</returns>
        </member>
        <member name="T:BeckmanCoulter.Silas.IDictionaryExtensions">
            <summary>
            Extension methods for IDictionary objects
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.IDictionaryExtensions.Merge``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Merge the items from one dictionary into a second dictionary (items from the source dictionary will overwrite items in the target if necessary)
            </summary>
            <typeparam name="TKey">The type of the keys from each dictionary</typeparam>
            <typeparam name="TValue">The type of the values from each dictionary</typeparam>
            <param name="target">The dictionary that will hold all the items</param>
            <param name="source">The dictionary that will have its items merged into the target</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.IDictionaryExtensions.ToDictionary``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``2},System.Func{``0,``3})">
            <summary>
            Create a dictionary from an IEnumerable. The resulting Dictionary type is specified as Generic parameter.
            </summary>
            <typeparam name="TSource">The type of elements in source enumerable</typeparam>
            <typeparam name="TDictionaryType">The type of Dictionary to create</typeparam>
            <typeparam name="TKey">The type of the Keys for the Dictionary to create</typeparam>
            <typeparam name="TElement">The type of Values for the Dictionary to create</typeparam>
            <param name="source">The enumerable to create the Dictionary from</param>
            <param name="keySelector">Function for how to create keys from the enumerable source</param>
            <param name="elementSelector">Function for how to create elements from the enumerable source</param>
            <returns>A new Dictionary object of type TDictionary created from the enumberable source and the selector functions</returns>
        </member>
        <member name="T:BeckmanCoulter.Silas.IMessageContext">
            <summary>
            The IMessageContext interface simply implements
            the IMessageContext&lt;ISilasMessage&gt; interface to make
            the syntax for working with IMessageContexts easier
            when the exact message type is unknown.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.MessageProcessorResponse">
            <summary>
            The MessageProcessorResponse enum is used
            by ISilasMessageProcessors to specify how
            processing should proceed after the 
            ISilasMessageProcessor has finished its
            processing.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.MessageProcessorResponse.RouteNow">
            <summary>
            Immediately route the current message without
            allowing any other ISilasMessageProcessors to
            process the message.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.MessageProcessorResponse.ContinueProcessing">
            <summary>
            Continue processing normally, allowing the
            remaining ISilasMessageProcessors to process
            the message.  If this is the final processor,
            then the message will be routed.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.MessageProcessorResponse.Discard">
            <summary>
            Stop all processing of the current message and
            do not route it.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.ISilasMessageProcessor">
            <summary>
            Classes implementing the ISilasMessageProcessor interface may be used to
            filter or modify messages as they are sent and received via an ISilasPortal.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasMessageProcessor.Process(BeckmanCoulter.Silas.IMessageContext{BeckmanCoulter.Silas.ISilasMessage},BeckmanCoulter.Silas.ISilasPortal)">
            <summary>
            Processes the message in the given context.
            </summary>
            <param name="messageContext">The IMessageContext containing the message and other information related to the message's transportation.</param>
            <param name="portal">The ISilasPortal that is having the message processed.</param>
            <returns>
            RouteNow if no more processing should be performed and the message should be routed immediately.  ContinueProcessing if the message 
            context should continue being processed by the remaining processors.  Discard if the message should go through no more processing and
            should also not be routed.
            </returns>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasMessageProcessor.DefaultPriority">
            <summary>
            The priority this message processor has when placed in the queue
            of processors.  A higher priority means that the processor will
            run earlier in the queue.  Because of this, filtering processors
            will want to have a higher priority while modifying processors
            may want a lower priority.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.ISilasMessageIncomingProcessor">
            <summary>
            Classes implementing ISilasMessageIncomingProcessor are explicitly
            indicating that they are message processors that handle messages
            that are being received by an ISilasPortal.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.ISilasMessageOutgoingProcessor">
            <summary>
            Classes implementing ISilasMessageOutgoingProcessor are explicitly
            indicating that they are message processors that handle messages
            that are being received by an ISilasPortal.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.RequestAll">
            <summary>
            Tells this SILAS portal to listen for all messages that are sent by
            SILAS.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Request(System.String)">
            <summary>
            Tells this SILAS portal to listen for any messages matching the 
            provided string.  The string should be in ToName:ToType:FromName:FromType:MessageType
            format.
            </summary>
            <param name="address">The address to begin listening for in ToName:ToType:FromName:FromType:MessageType format</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Request(BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Tells this SILAS portal to listen for any messages matching the
            given MessageAddress.
            </summary>
            <param name="address">The MessageAddress to begin listening for.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Request(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Tells this SILAS portal to listen for all messages matching any
            of the given addresses.  Each address should be in ToName:ToType:FromName:FromType:MessageType
            format.
            </summary>
            <param name="addresses">The collection of addresses to begin listening for, each in ToName:ToType:FromName:FromType:MessageType format.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Request(System.Collections.Generic.IEnumerable{BeckmanCoulter.Silas.Messages.IMessageAddress})">
            <summary>
            Tells this SILAS portal to listen for all messages matching any
            of the given addresses.
            </summary>
            <param name="addresses">The collection of addresses to begin listening for.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.IgnoreAll">
            <summary>
            Tells the SILAS portal to ignore all messages sent by SILAS.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Ignore(System.String)">
            <summary>
            Tells the SILAS portal to ignore all messages that match the given address.
            The address should be in ToName:ToType:FromName:FromType:MessageType format.
            Note that this will have no effect if the portal has not already been told to listen for messages from the given
            address (or some superset).
            </summary>
            <param name="address">The address to ignore.  Should be in ToName:ToType:FromName:FromType:MessageType format.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Ignore(BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Tells the SILAS portal to ignore all messages that match the given address.
            Note that this will have no effect if the portal has not already been told to listen for messages from the given
            address (or some superset).
            </summary>
            <param name="address">The address to ignore.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Ignore(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Tells the SILAS portal to ignore all messages that match any of the given addresses.
            Each address should be in ToName:ToType:FromName:FromType:MessageType format.
            Note that this will have no effect if the portal has not already been told to listen for messages from the given
            address (or some superset).
            </summary>
            <param name="addresses">The collection of addresses to be ignored, each in ToName:ToType:FromName:FromType:MessageType format.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Ignore(System.Collections.Generic.IEnumerable{BeckmanCoulter.Silas.Messages.IMessageAddress})">
            <summary>
            Tells the SILAS portal to ignore all messages that match any of the given addresses.
            Note that this will have no effect if the portal has not already been told to listen for messages from the given
            address (or some superset).
            </summary>
            <param name="addresses"></param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Send(BeckmanCoulter.Silas.ISilasMessage,System.String)">
            <summary>
            Sends a SILAS message to a specified address.  The address should be in
            ToName:ToType:FromName:FromType:MessageType format.
            </summary>
            <param name="message">The SILAS message to be sent.</param>
            <param name="address">The address that the message will be sent to.  Should be in ToName:ToType:FromName:FromType:MessageType format.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Send(BeckmanCoulter.Silas.ISilasMessage,BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Sends a SILAS message to a specified address.
            </summary>
            <param name="message">The SILAS message to be sent.</param>
            <param name="address">The address that the message will be sent to.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Expect(System.String,System.Int32)">
            <summary>
            Waits for a message sent to the given address and then returns that message.  If
            the given timeout period expires, a TimeoutException is thrown.
            </summary>
            <param name="addressedTo">The address that the message was sent to.  Should be in ToName:ToType:FromName:FromType:MessageType format.</param>
            <param name="timeoutMs">The amount of time to wait for a matching message.</param>
            <returns>The message that was sent to the given address.</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Expect(BeckmanCoulter.Silas.Messages.IMessageAddress,System.Int32)">
            <summary>
            Waits for a message sent to the given address and then returns that message.  If
            the given timeout period expires, a TimeoutException is thrown.
            </summary>
            <param name="addressedTo">The address that the message was sent to.</param>
            <param name="timeoutMs">The amount of time to wait for a matching message (in milliseconds).</param>
            <returns>The message that was sent to the given address.</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Expect(System.String,System.TimeSpan)">
            <summary>
            Waits for a message sent to the given address and then returns that message.  If
            the given timeout period expires, a TimeoutException is thrown.
            </summary>
            <param name="addressedTo">The address that the message was sent to.</param>
            <param name="timeout">The amount of time to wait for a matching message.</param>
            <returns>The message that was sent to the given address.</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Expect(BeckmanCoulter.Silas.Messages.IMessageAddress,System.TimeSpan)">
            <summary>
            Waits for a message sent to the given address and then returns that message.  If
            the given timeout period expires, a TimeoutException is thrown.
            </summary>
            <param name="addressedTo">The address that the message was sent to.</param>
            <param name="timeout">The amount of time to wait for a matching message.</param>
            <returns>The message that was sent to the given address.</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.SendAndExpect(BeckmanCoulter.Silas.ISilasMessage,System.String,System.String,System.Int32)">
            <summary>
            Sends the given message to a specified address and then waits for a message to be
            sent on a separate address and returns that message.  If the given timeout period
            expires, a TimeoutException is thrown.
            </summary>
            <param name="message">The message to be sent.</param>
            <param name="sendToAddress">The address that the message will be sent to.  Should be in ToName:ToType:FromName:FromType:MessageType format.</param>
            <param name="expectAddressedTo">The address at which to listen for a reply.  Should be in ToName:ToType:FromName:FromType:MessageType format.</param>
            <param name="timeoutMs">The amount of time to wait for a matching message (in milliseconds).</param>
            <returns>The message that was received.</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.SendAndExpect(BeckmanCoulter.Silas.ISilasMessage,BeckmanCoulter.Silas.Messages.IMessageAddress,BeckmanCoulter.Silas.Messages.IMessageAddress,System.Int32)">
            <summary>
            Sends the given message to a specified address and then waits for a message to be
            sent on a separate address and returns that message.  If the given timeout period
            expires, a TimeoutException is thrown.
            </summary>
            <param name="message">The message to be sent.</param>
            <param name="sendToAddress">The address that the message will be sent to.</param>
            <param name="expectAddressedTo">The address at which to listen for a reply.</param>
            <param name="timeoutMs">The amount of time to wait for a matching message (in milliseconds).</param>
            <returns>The message that was received.</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.SendAndExpect(BeckmanCoulter.Silas.ISilasMessage,System.String,System.String,System.TimeSpan)">
            <summary>
            Sends the given message to a specified address and then waits for a message to be
            sent on a separate address and returns that message.  If the given timeout period
            expires, a TimeoutException is thrown.
            </summary>
            <param name="message">The message to be sent.</param>
            <param name="sendToAddress">The address that the message will be sent to.  Should be in ToName:ToType:FromName:FromType:MessageType format.</param>
            <param name="expectAddressedTo">The address at which to listen for a reply.  Should be in ToName:ToType:FromName:FromType:MessageType format.</param>
            <param name="timeout">The amount of time to wait for a matching message.</param>
            <returns>The message that was received.</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.SendAndExpect(BeckmanCoulter.Silas.ISilasMessage,BeckmanCoulter.Silas.Messages.IMessageAddress,BeckmanCoulter.Silas.Messages.IMessageAddress,System.TimeSpan,System.Func{BeckmanCoulter.Silas.IMessageContext,System.Boolean})">
            <summary>
            Sends the given message to a specified address and then waits for a message to be
            sent on a separate address and returns that message.  If the given timeout period
            expires, a TimeoutException is thrown.
            </summary>
            <param name="message">The message to be sent.</param>
            <param name="sendToAddress">The address that the message will be sent to.</param>
            <param name="expectAddressedTo">The address at which to listen for a reply.</param>
            <param name="timeout">The amount of time to wait for a matching message.</param>
            <param name="condition">A condition that will be used when a message matches the given address to determine if it is the one that should be returned.  Defaults to no condition (first message received is returned).</param>
            <returns>The message that was received.</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.SendAndObserve(BeckmanCoulter.Silas.ISilasMessage,BeckmanCoulter.Silas.Messages.IMessageAddress,BeckmanCoulter.Silas.Messages.IMessageAddress,System.TimeSpan,System.Func{BeckmanCoulter.Silas.IMessageContext,System.Boolean})">
            <summary>
            Send a message and return an IObservable that can be used to receive responses.
            </summary>
            <param name="message">The message that will be sent</param>
            <param name="requestAddress">The address to which the message will be sent</param>
            <param name="replyAddress">The address of messages that will be passed through the returned observable</param>
            <param name="timeout">The amount of time for which the returned IObservable should listen for replies</param>
            <param name="condition">A condition that will be applied to each incoming message when inspecting incoming messages for a reply</param>
            <returns>
            An observable which contains all messages matching the replyAddress from the time the message was sent.
            Note that each time an observer subscribes to this IObservable, all the messages will be processed by the
            observer (not just ones received from the time the observer subscribes).
            </returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Register(System.String,System.String)">
            <summary>
            Register this portal with the SILAS kernel.  If a module name and/or
            module type are given, the portal will register using them.  Otherwise,
            the portal will register with its current name and type.
            </summary>
            <param name="moduleName">An optional name to use when registering.  If no value is given, the portal's current name is used.</param>
            <param name="moduleType">An optional type to use when registering.  If no value is given, the portal's current type is used.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.ISilasPortal.Unregister">
            <summary>
            Unregister this portal.  The portal will no longer receive messages
            and cannot be used to send messages.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasPortal.RequestedAddresses">
            <summary>
            All of the addresses that the SILAS portal is currently listening for.  Use
            the <seealso cref="M:BeckmanCoulter.Silas.ISilasPortal.Request(System.String)">Request</seealso> and <seealso cref="M:BeckmanCoulter.Silas.ISilasPortal.Ignore(System.String)">Ignore</seealso>
            methods to add or remove from this collection.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasPortal.ReceivedMessages">
            <summary>
            Use this IObservable to receive messages that are collected by the SILAS
            portal.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasPortal.SentMessages">
            <summary>
            Use this IObservable to be given messages as they are sent by this SILAS
            portal.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasPortal.Name">
            <summary>
            The name that this portal will use when registering with the SILAS kernel.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasPortal.Type">
            <summary>
            The type that this portal will use when registering with the SILAS kernel.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasPortal.IsRegistered">
            <summary>
            Whether or not this portal has been registered with the SILAS kernel.  If
            this is false, then messages will not be received and cannot be sent.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.ISilasPortal.IsInUse">
            <summary>
            Whether or not the portal is currently in the middle of processing a
            request.  If the portal is in use, it cannot be disposed.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.AbortMessage">
            <summary>
            Default implementation of an Abort message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.AbortMessage.#ctor">
            <summary>
            Create a new default Abort message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.AbortReplyMessage">
            <summary>
            Default implementation of an Abort Reply message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.AbortReplyMessage.#ctor">
            <summary>
            Create a new default Abort Reply message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.CommandMessage">
            <summary>
            Default implementation of the Command SILAS message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.CommandMessage`1">
            <summary>
            Default implementation of the Command SILAS message with custom command parameters
            </summary>
            <typeparam name="TParam">The type of the custom command parameters object</typeparam>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ICommandMessage`1">
            <summary>
            This message is usually sent to a device module.  It describes the action to be taken.
            </summary>
            <typeparam name="TParam">The type of the custom command parameters object</typeparam>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ICommandMessage">
            <summary>
            This message is usually sent to a device module.  It describes the action to be taken.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandMessage.CommandName">
            <summary>
            The name of the command to be executed.  Standard command names include 
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandMessage.Verify">
            <summary>
            The only possible value is True.  If this field is present (and contains “True”), the command is being verified rather than executed.  The module will simply verify that it can execute the command.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandMessage.Transports">
            <summary>
            A sub-message with a leaf (numbered keys 1 to n) for each transport involved.  (single capacity instruments would always use just 1).  The leaf contents will be the ID of the transport.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandMessage.Parameters">
            <summary>
            A sub-message with parameters describing the command under separate keys (e.g., Wavelength, Method )
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandMessage.Replace">
            <summary>
            A sub-message that includes a Parameters branch that can be used to push run-time values
            into the Parameters branch.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandMessage.Comment">
            <summary>
            Any comments about the command
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandMessage.Tags">
            <summary>
            Additional information about the message or the sender or the message
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ICommandMessage`1.Parameters">
            <summary>
            A sub-message with parameters describing the command under separate keys (e.g., Wavelength, Method )
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.CommandMessage`1.#ctor">
            <summary>
            Create default Command SILAS message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.CommandMessage`1.#ctor(System.String,System.Boolean,BeckmanCoulter.Silas.Messages.OneBasedValueList)">
            <summary>
            Create Command SILAS message with given command name, transports, and verification request
            </summary>
            <param name="commandName">The name of the command</param>
            <param name="verify">True if the command should only be verified, not run</param>
            <param name="transports">The transports involved with this command</param>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.CommandMessage`1.Tags">
            <summary>
            Additional information about the message or the sender or the message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.CommandMessage.#ctor">
            <summary>
            Create default Command SILAS message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.CommandMessage.#ctor(System.String,System.Boolean,BeckmanCoulter.Silas.Messages.OneBasedValueList)">
            <summary>
            Create Command SILAS message with given command name, transports, and verification request
            </summary>
            <param name="commandName">The name of the command</param>
            <param name="verify">True if the command should only be verified, not run</param>
            <param name="transports">The transports involved with this command</param>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.CommandParametersMessage">
            <summary>
            Default implementation of the Parameters branch of a Command SILAS message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.CommandParametersMessage.#ctor">
            <summary>
            Create default parameters branch
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.DeviceErrorMessage">
            <summary>
            Default implementation of a Device Error SILAS message
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IDeviceErrorMessage">
            <summary>
            This message is sent by a module when an error occurs.  It describes the error and the state of the module.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceErrorMessage.ErrorLevel">
            <summary>
            One of [Fatal, Partially Fatal, Log, Unknown]
            - If it is Fatal, the error was fatal to the module sending it; the module no longer functions at all.  At some time, it may come back on-line.  At that time, it would broadcast a Status message indicating such.
            - If Partially Fatal, the error was fatal for some portion of the functionality of the module (e.g., one of two pumps has failed).  The remaining functionality may be determined by sending an Existence Query message and examining the Commands key of the Status message sent out.
            - If Log, the error was a minor one, not affecting the functionality of the module.  For example, a bad command is a Log error to the device given the command.  For the Executive or other controller, it may be fatal.
            - The Unknown level will be supplied by a module such as the Executive when passing on a message and an original Error Level was not given.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceErrorMessage.ErrorType">
            <summary>
            A comma delimited list of all the following that apply (may be none):
            Busy							- module is too busy to execute a command
            Bad Command				- module received a bad command
            Hardware Failure	- (see Recovery and Error Text)
            Software Failure
            Hardware Communication Failure
            Software Communication Failure
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceErrorMessage.Recovery">
            <summary>
            A comma delimited list of all that apply (may be none if unrecoverable):
            User Intervention  			- the user should see Error Text and then
            													be able to retry this command, skip it, or stop
            Requires User Interface	- recovery will require the module to put up its 
            													own user interface for a time
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceErrorMessage.ErrorText">
            <summary>
            Text error description aimed at the user; should also be appropriate for log files.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceErrorMessage.StackTrace">
            <summary> Optional stack trace.  May be null. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceErrorMessage.Picture">
            <summary>
            The a base 64 encoded bitmap (BMP file)
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceErrorMessage.TimeStamp">
            <summary>
            The time that the error occurred.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IDeviceErrorMessage.DueToMsg">
            <summary>
            The message that caused the error (e.g., the command that smashed the robot into the wall).
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.DeviceErrorMessage.#ctor">
            <summary>
            Create a default Device Error SILAS message
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.DeviceErrorMessage.#ctor(BeckmanCoulter.Silas.Messages.ErrorLevel,BeckmanCoulter.Silas.Messages.ErrorType)">
            <summary>
            Create a Device Error SILAS message with the given error level and error type
            </summary>
            <param name="errorLevel">The error level of the device error (defaults to ErrorLevel.Unknown)</param>
            <param name="errorType">The error type of the device error (defaults to ErrorType.SoftwareFailure)</param>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ErrorLevel">
            <summary> The severity of an error. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorLevel.Fatal">
            <summary> Normally indicates that the module may not continue to function. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorLevel.PartiallyFatal">
            <summary> Normally indicates that part of the module may not continue to function. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorLevel.Log">
            <summary> Normally indicates that the module should continue to function, though the command this is referring to did fail. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorLevel.Unknown">
            <summary> Unknown. </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ErrorType">
            <summary> Kinds of errors. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorType.Busy">
            <summary> The module got a command while it was busy. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorType.BadCommand">
            <summary> The command was ill-formed. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorType.HardwareFailure">
            <summary> The hardware failed. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorType.SoftwareFailure">
            <summary> The software failed. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorType.HardwareCommunicationFailure">
            <summary> The hardware failed to communicate. </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.ErrorType.SoftwareCommunicationFailure">
            <summary> The software failed. </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.IMessageAddress">
            <summary>
            A SILAS address
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.IMessageAddress.Matches(BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Determine if the current address "matches" the given one.  The
            method checks that the message type, target, and source are the
            same for both the current address and the one being provided.
            Parts of the current address that are set to "*" automatically
            match the corresponding part in the given address.
            </summary>
            <example>
            An address of "*:*:*:*:Command" matches any message that has
            a message type of "Command".
            </example>
            <param name="address">The address that the current address will be matched against</param>
            <returns>True if the current address matches the given one, false otherwise</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.IMessageAddress.MatchesAny(System.Collections.Generic.IEnumerable{BeckmanCoulter.Silas.Messages.IMessageAddress})">
            <summary>
            Determine if the current address "matches" all the given addresses.
            The method checks that the message type, target, and source are
            the same for both the current address and those being provided.
            Parts of the current address that are set to "*" automatically
            match the corresponding part in the given addresses.
            </summary>
            <param name="addresses">The addresses that the current address will be matched against</param>
            <returns>True if the current address matches each of the given addresses, false otherwise</returns>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IMessageAddress.Alias">
            <summary>
            An alias for the address (primarily used when defining translations)
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IMessageAddress.MsgType">
            <summary>
            The type of the message (e.g. Command)
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IMessageAddress.ToName">
            <summary>
            The target of the message
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IMessageAddress.FromName">
            <summary>
            The sender of the message
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IMessageAddress.ToType">
            <summary>
            The type of the target
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.IMessageAddress.FromType">
            <summary>
            The type of the sender
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.MessageAddress">
            <summary>
            Default implementation of a SILAS address
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.MessageAddress.AddressFormat">
            <summary>
            The format that an address is expected to be in when stored as a string
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.MessageAddress.#ctor">
            <summary>
            Create a default address (wildcards in each part of the address)
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.MessageAddress.#ctor(System.String)">
            <summary>
            Create an address with the given message type (each other part of the address will
            be set to the wildcard)
            </summary>
            <param name="msgType"></param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.MessageAddress.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Create an address with the given message type, target, source, and, optionally, alias.
            </summary>
            <param name="msgType">The type of the message the address will use</param>
            <param name="toName">The target of any message sent using the address</param>
            <param name="fromName">The source of any message sent using the address</param>
            <param name="alias">The alias of the address (used in translations)</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.MessageAddress.#ctor(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Create an address with the given message type, target, target type, source, source type, and, optionally, alias.
            </summary>
            <param name="msgType">The type of the message the address will use</param>
            <param name="toName">The target of any message sent using the address</param>
            <param name="toType">The target type of any message sent using the address</param>
            <param name="fromName">The source of any message sent using the address</param>
            <param name="fromType">The source type of any message sent using the address</param>
            <param name="alias">The alias of the address (used in translations)</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.MessageAddress.Equals(System.Object)">
            <summary>
            Determines whether this instance of MessageAddress and a specified object, which must also
            be a MessageAddress, have the same value
            </summary>
            <param name="obj">An object to compare</param>
            <returns>True if the given object is equivalent to the current object, false otherwise</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.MessageAddress.Parse(System.String,BeckmanCoulter.Silas.Messages.MessageAddressFormat)">
            <summary>
            Attempt to parse a string into a MessageAddress object.  The string's format
            must match the given MessageAddressFormat
            </summary>
            <param name="address">The string to be parsed into a MessageAddress</param>
            <param name="format">The format of the string being parsed</param>
            <returns>A MessageAddress object equivalent to the provided string</returns>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.Messages.MessageAddress.Parse(System.String)">
            <summary>
            Attempt to parse a string into a MessageAddress object
            </summary>
            <param name="address">The string to be parsed into a MessageAddress</param>
            <returns>A MessageAddress object equivalent to the provided string</returns>
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.MessageAddressFormat">
            <summary>
            Formats in which a SILAS message may be stored or presented.
            </summary>
            <seealso cref="M:BeckmanCoulter.Silas.Messages.MessageAddress.TryParse(System.String,BeckmanCoulter.Silas.Messages.MessageAddressFormat,BeckmanCoulter.Silas.Messages.MessageAddress@)"/>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.MessageAddressFormat.Display">
            <summary>
            <para>The standard display format for as SILAS address.</para>
            <code>[&lt;Message Type&gt;] &lt;From Name&gt;:&lt;From Type&lt; --&gt; &lt;To Name&gt;:&lt;To Type&gt;</code>
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Messages.MessageAddressFormat.Protocol">
            <summary>
            <para>The SILAS address protocol format typically seen in Beckman Coulter application development.</para>
            <code>&lt;To Name&gt;:&lt;To Type&lt;:&lt;From Name&gt;:&lt;From Type&gt;:&lt;Message Type&gt;</code>
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.PauseMessage">
            <summary> This message tells a device to pause what it is doing.  Modules are not required to implement or reply to this. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.PauseMessage.Index">
            <summary> If the device being aborted deals with multiple transports, this key must indicate which part of the 
            device to abort (e.g., one of the four parts of a tetrad). </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.ResumeMessage">
            <summary> This message tells a device to continue after a Pause.  Modules that respond to pause should also respond to 
            Resume.  All other modules may ignore it. </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.ResumeMessage.Index">
            <summary> If the device being resumed deals with multiple transports, this key must indicate which part of the 
            device to resume (e.g., one of the four parts of a tetrad). </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Collections.SparseList`2">
            <summary>
            Implementation of a sparse list/array.  The key type of the underlying dictionary
            can be any type, but functions to convert it to/from an int must be provided.
            </summary>
            <typeparam name="TKey">The type that is used to index the underlying dictionary.</typeparam>
            <typeparam name="TValue">The type of the values stored in the sparse list.</typeparam>
        </member>
        <member name="M:BeckmanCoulter.Silas.Collections.SparseList`2.CopyTo(`1[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="T:BeckmanCoulter.Silas.Messages.StructuredStackTrace">
            <summary> A stack trace that is structured to split out the lines so they can be decently viewed in a tree view that sorts the
            keys alphabetically.  </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Messages.StructuredStackTrace.FullText">
            <summary> The full text of the stack trace. </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.MessageTypes">
            <summary>
            A helper class that can be used to register factory methods for different message types as well
            as the default reply address for messages.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.MessageTypes.RequestAndReplies">
            <summary>
            Known message types and their replies.  This dictionary is consulted when replying to
            an IMessageContext from the SilasPortal.  Developers may add or change items in this
            dictionary to fit their requirements.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.MessageTypes.GetDefaultMessageFactory">
            <summary>
            Get a function that can be called to create an ISilasMessage (defaults to SilasMessage)
            </summary>
            <returns>A function that will create an ISilasMessage</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.MessageTypes.GetMessageFactory(System.String)">
            <summary>
            Get a function that can be called to create an ISilasMessage matching the given
            messageType.  For example, in the default implementation, passing "Command" to this
            method will return a function that will create a CommandMessage object.
            </summary>
            <param name="messageType">The message type of the desired message object (e.g. "Command", "Status Query", etc.)</param>
            <returns>A function that will create an ISilasMessage matching the given messageType or the default ISilasMessage if the messageType could not be found.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.MessageTypes.CreateInstance">
            <summary>
            Get an instance of the default ISilasMessage class (defaults to SilasMessage)
            </summary>
            <returns>An ISilasMessage created by the default message factory</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.MessageTypes.CreateInstanceOfType(System.String)">
            <summary>
            Get an ISilasMessage instance matching the given messageType
            </summary>
            <param name="messageType">The message type of the desired message object (e.g. "Command", "Status Query", etc.)</param>
            <returns>An instance of ISilasMessage matching the given messageType or an instance of the default ISilasMessage if the given messageType was not found.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.MessageTypes.SetDefaultMessageType``1">
            <summary>
            Register TMessage as the default ISilasMessage class 
            </summary>
            <typeparam name="TMessage">The type that will be used as the default ISilasMessage</typeparam>
        </member>
        <member name="M:BeckmanCoulter.Silas.MessageTypes.SetMessageType``1(System.String)">
            <summary>
            Register TMessage as the default ISilasMessage class for the given messageType.
            </summary>
            <typeparam name="TMessage">The type that will be used as the default ISilasMessage for the given messageType</typeparam>
            <param name="messageType">The message type for which the given TMessage will be the default class</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.MessageTypes.GetReply(BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Get the reply address for this given address.  Note that this does not take into account %MN and %RN values
            in the address.
            </summary>
            <param name="address">The address to which a reply will be given</param>
            <returns>The reply address for the given address</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.ObservableSilasMessageExtensions.RemoveUnnecessaryAddresses(System.Collections.Generic.IEnumerable{BeckmanCoulter.Silas.Messages.IMessageAddress})">
            <summary>
            Removes any message addresses that are unnecessary because other addresses
            being requested are more inclusive.  For example, if the group has one
            address of *:*:*:*:Command and the other is *:*:Keeper:*:Command, then
            the one that references the Keeper will be removed because the other
            address will also capture commands from the Keeper.
            </summary>
            <returns>Returns only the necessary addresses.</returns>
        </member>
        <member name="P:BeckmanCoulter.Silas.Serialization.Formatters.SilasRawFormatter.SurrogateSelector">
            <summary>The "raw" SILAS format does not allow for anything to be serialized
            except the messages and values on the message, so we aren't going to
            be delegating serialization duties to any other object.</summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Serialization.Formatters.SilasRawFormatter.Binder">
            <summary>This object is not needed by the SilasRawFormatter because no type 
            information is contained in the serialized format.  Instead, the
            formatter relies on the BaseMessageType property and the SilasFactory
            property to create the correct type.</summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.SilasMessageHelpers">
            <summary>
            The SilasMessageHelpers class provides a set of extension methods and other
            static methods for classes deriving from the SilasMessage class.  In particular,
            this class provides convenience methods for mapping entries in a SILAS message
            to members of a SilasMessage based class.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapMessage``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Map a member implementing ISilasMessage to a sub-message of a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped sub-message can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TMember">The type of the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Parameters)</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapMessage``2(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Map a member implementing ISilasMessage to a sub-message of a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TMember">The type of the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped sub-message can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Parameters)</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapMessage``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{System.Object,BeckmanCoulter.Silas.ISilasMessage},System.Func{BeckmanCoulter.Silas.ISilasMessage,System.Object})">
            <summary>
            Map a member implementing ISilasMessage to a sub-message of a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped sub-message can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TMember">The type of the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Parameters)</param>
            <param name="toMessage">A function that will be used when converting the underlying ISilasMessage into the type of the member being mapped</param>
            <param name="fromMessage">A function that will be used when converting the mapped member to the ISilasMessage in the underlying messages dictionary</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapMessage``2(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{System.Object,BeckmanCoulter.Silas.ISilasMessage},System.Func{BeckmanCoulter.Silas.ISilasMessage,System.Object})">
            <summary>
            Map a member implementing ISilasMessage to a sub-message of a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TMember">The type of the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped sub-message can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Parameters)</param>
            <param name="toMessage">A function that will be used when converting the underlying ISilasMessage into the type of the member being mapped</param>
            <param name="fromMessage">A function that will be used when converting the mapped member to the ISilasMessage in the underlying messages dictionary</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapString``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.String}})">
            <summary>
            Map a string member to a value in a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped string can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ComPort)</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapString``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.String}})">
            <summary>
            Map a string member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ComPort)</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapValue``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``1,System.String},System.Func{System.String,``1})">
            <summary>
            Map a member to a value in a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped string can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TMember">The type of the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ComPort)</param>
            <param name="toString">A function that will be used to convert the mapped member to a string that can be stored in the SILAS message</param>
            <param name="fromString">A function that will be used to convert the string in the SILAS message to the type of the mapped member</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapValue``2(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``1,System.String},System.Func{System.String,``1})">
            <summary>
            Map a member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TMember">The type of the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ComPort)</param>
            <param name="toString">A function that will be used to convert the mapped member to a string that can be stored in the SILAS message</param>
            <param name="fromString">A function that will be used to convert the string in the SILAS message to the type of the mapped member</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapBool``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Boolean)">
            <summary>
            Map a bool member to a value in a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped string can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.IsHardwareEnabled)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a bool</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapBool``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Boolean)">
            <summary>
            Map a bool member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.IsHardwareEnabled)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a bool</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapBool``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Boolean}}},System.Nullable{System.Boolean})">
            <summary>
            Map a nullable bool member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.IsHardwareEnabled)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a bool</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapBool``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Boolean}}},System.Nullable{System.Boolean})">
            <summary>
            Map a nullable bool member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.IsHardwareEnabled)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a bool</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapInt``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Int32}},System.Int32)">
            <summary>
            Map an int member to a value in a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped string can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.EstimatedTime)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into an int</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapInt``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Int32}},System.Int32)">
            <summary>
            Map an int member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.EstimatedTime)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into an int</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapInt``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}},System.Nullable{System.Int32})">
            <summary>
            Map a nullable int member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.EstimatedTime)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into an int</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapInt``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}},System.Nullable{System.Int32})">
            <summary>
            Map a nullable int member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.EstimatedTime)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into an int</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDouble``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Double}},System.Double)">
            <summary>
            Map a double member to a value in a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped string can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Percentage)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a double</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDouble``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Double}},System.Double)">
            <summary>
            Map a double member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Percentage)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a double</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDouble``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}},System.Nullable{System.Double})">
            <summary>
            Map a nullable double member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Percentage)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a double</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDouble``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}},System.Nullable{System.Double})">
            <summary>
            Map a nullable double member to a value in a SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Percentage)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a double</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDecimal``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}},System.Decimal)">
            <summary>
            Map a decimal member to a value in a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped string can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Speed)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a decimal</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDecimal``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}},System.Decimal)">
            <summary>
            Map a decimal member to a value in a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped string can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found </param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Speed)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a decimal</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDecimal``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}},System.Nullable{System.Decimal})">
            <summary>
            Map a decimal member to a value in a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped string can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Speed)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a decimal</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDecimal``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}},System.Nullable{System.Decimal})">
            <summary>
            Map a nullable decimal member to a value in a SILAS message.
            The name of the member will be used as the key into the SILAS message where
            the mapped string can be found.  The member being mapped can be either
            a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found </param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Speed)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a decimal</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapEnum``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1)">
            <summary>
            Map an enum member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TEnum">The type of the enum being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ProtocolType)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into the enum</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapEnum``2(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1)">
            <summary>
            Map an enum member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TEnum">The type of the enum being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ProtocolType)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into the enum</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapEnum``2(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}},System.Nullable{``1})">
            <summary>
            Map a nullable enum member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TEnum">The type of the enum being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ProtocolType)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into the enum</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapEnum``2(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}},System.Nullable{``1})">
            <summary>
            Map a nullable enum member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TEnum">The type of the enum being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ProtocolType)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into the enum</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapEnumWithDescriptions``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1)">
            <summary>
            Map an enum member to a value in the SILAS message based on the enum value's description.
            The member being mapped can be either a property or field.
            </summary>
            <remarks>
            <example>
            <para>
            When mapping the enum in the example below, the SilasMessage will use either "Built-in protocol" or "User defined protocol"
            as the item's value in the Values dictionary for the Type property.
            </para>
            <code lang="C#">
            	public enum ProtocolType
            	{
            		[Description("Built-in protocol")]
            		BuiltIn,
            		[Description("User defined protocol")]
            		UserDefined
            	}
            
            	public class ProtocolMessage : SilasMessage
            	{
            		public ProtocolType Type { get; set; }
            
            		public ProtocolMessage()
            		{
            			this.MapEnumWithDescription(m => m.Type, ProtocolType.UserDefined);
            
            			Debug.WriteLine("This should be 'User defined protocol': " + this.Values["Type"]);
            		}
            	}
            </code>
            </example>
            </remarks>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TEnum">The type of the enum being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ProtocolType)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into the enum</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapEnumWithDescriptions``2(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1)">
            <summary>
            Map an enum member to a value in the SILAS message based on the enum value's description.
            The member being mapped can be either a property or field.
            </summary>
            <remarks>
            <example>
            <para>
            When mapping the enum in the example below, the SilasMessage will use either "Built-in protocol" or "User defined protocol"
            as the item's value in the Values dictionary for the Type property.
            </para>
            <code lang="C#">
            	public enum ProtocolType
            	{
            		[Description("Built-in protocol")]
            		BuiltIn,
            		[Description("User defined protocol")]
            		UserDefined
            	}
            
            	public class ProtocolMessage : SilasMessage
            	{
            		public ProtocolType Type { get; set; }
            
            		public ProtocolMessage()
            		{
            			this.MapEnumWithDescription(m => m.Type, ProtocolType.UserDefined);
            
            			Debug.WriteLine("This should be 'User defined protocol': " + this.Values["Type"]);
            		}
            	}
            </code>
            </example>
            </remarks>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TEnum">The type of the enum being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ProtocolType)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into the enum</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapEnumWithDescriptions``2(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}},System.Nullable{``1})">
            <summary>
            Map a nullable enum member to a value in the SILAS message based on the enum value's description.
            The member being mapped can be either a property or field.
            </summary>
            <remarks>
            <example>
            <para>
            When mapping the enum in the example below, the SilasMessage will use either "Built-in protocol" or "User defined protocol"
            as the item's value in the Values dictionary for the Type property.
            </para>
            <code lang="C#">
            	public enum ProtocolType
            	{
            		[Description("Built-in protocol")]
            		BuiltIn,
            		[Description("User defined protocol")]
            		UserDefined
            	}
            
            	public class ProtocolMessage : SilasMessage
            	{
            		public ProtocolType? Type { get; set; }
            
            		public ProtocolMessage()
            		{
            			this.MapEnumWithDescription(m => m.Type, ProtocolType.UserDefined);
            
            			this.Type = ProtocolType.UserDefined;
            
            			Debug.WriteLine("This should be 'User defined protocol': " + this.Values["Type"]);
            		}
            	}
            </code>
            </example>
            </remarks>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TEnum">The type of the enum being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ProtocolType)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into the enum</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapEnumWithDescriptions``2(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{``1}}},System.Nullable{``1})">
            <summary>
            Map a nullable enum member to a value in the SILAS message based on the enum value's description.
            The member being mapped can be either a property or field.
            </summary>
            <remarks>
            <example>
            <para>
            When mapping the enum in the example below, the SilasMessage will use either "Built-in protocol" or "User defined protocol"
            as the item's value in the Values dictionary for the Type property.
            </para>
            <code lang="C#">
            	public enum ProtocolType
            	{
            		[Description("Built-in protocol")]
            		BuiltIn,
            		[Description("User defined protocol")]
            		UserDefined
            	}
            
            	public class ProtocolMessage : SilasMessage
            	{
            		public ProtocolType? Type { get; set; }
            
            		public ProtocolMessage()
            		{
            			this.MapEnumWithDescription(m => m.Type, ProtocolType.UserDefined);
            
            			this.Type = ProtocolType.UserDefined;
            
            			Debug.WriteLine("This should be 'User defined protocol': " + this.Values["Type"]);
            		}
            	}
            </code>
            </example>
            </remarks>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <typeparam name="TEnum">The type of the enum being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.ProtocolType)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into the enum</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDateTime``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.DateTime}},System.DateTime)">
            <summary>
            Map a DateTime member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.StartTime)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a DateTime</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDateTime``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.DateTime}},System.DateTime)">
            <summary>
            Map a DateTime member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.StartTime)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a DateTime</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDateTime``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.DateTime}}},System.Nullable{System.DateTime})">
            <summary>
            Map a nullable DateTime member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.StartTime)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a DateTime</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapDateTime``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.DateTime}}},System.Nullable{System.DateTime})">
            <summary>
            Map a nullable DateTime member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.StartTime)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a DateTime</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapOleDateTime``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.DateTime}},System.DateTime)">
            <summary>
            Map a OLE formatted DateTime member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.StartTime)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a DateTime</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapOleDateTime``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.DateTime}},System.DateTime)">
            <summary>
            Map a OLE formatted DateTime member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.StartTime)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a DateTime</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapOleDateTime``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.DateTime}}},System.Nullable{System.DateTime})">
            <summary>
            Map a nullable OLE formatted DateTime member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.StartTime)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a DateTime</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapOleDateTime``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.DateTime}}},System.Nullable{System.DateTime})">
            <summary>
            Map a nullable OLE formatted DateTime member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.StartTime)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a DateTime</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapGuid``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Guid}},System.Guid)">
            <summary>
            Map a Guid member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Id)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a Guid</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapGuid``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Guid}},System.Guid)">
            <summary>
            Map a Guid member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Id)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a Guid</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapGuid``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Guid}}},System.Nullable{System.Guid})">
            <summary>
            Map a nullable Guid member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Id)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a Guid</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapGuid``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Guid}}},System.Nullable{System.Guid})">
            <summary>
            Map a nullable Guid member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Id)</param>
            <param name="defaultValue">The value that will be used if the string exists in the SILAS message but cannot be parsed into a Guid</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapVersion``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Version}},System.Version)">
            <summary>
            Map a Version member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Id)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a Version</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapVersion``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Version}},System.Version)">
            <summary>
            Map a Version member to a value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Id)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a Version</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapBase64``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Byte[]}},System.Byte[])">
            <summary>
            Map a byte array member to a base 64 encoded value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Picture)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a base 64 decoded byte array</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.MapBase64``1(``0,System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Byte[]}},System.Byte[])">
            <summary>
            Map a byte array member to a base 64 encoded value in the SILAS message.
            The member being mapped can be either a property or field.
            </summary>
            <typeparam name="TCurrentClass">The type of the class that has the member being mapped</typeparam>
            <param name="msg">The SilasMessage that is having a member mapped</param>
            <param name="key">The key into the SILAS message where the mapped string can be found</param>
            <param name="member">An expression that points to the member to be mapped (e.g. m => m.Picture)</param>
            <param name="defaultValue">The value that will be used if the string in the SILAS message cannot be parsed into a base 64 decoded byte array</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.Save(BeckmanCoulter.Silas.ISilasMessage,System.String)">
            <summary>
            Saves the given ISilasMessage to a Keeper branch (.brc) formatted file.
            </summary>
            <param name="msg">The message to be saved.</param>
            <param name="path">The path to the file where the message will be saved.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.Save(BeckmanCoulter.Silas.ISilasMessage,System.IO.Stream)">
            <summary>
            Saves the given ISilasMessage to a Keeper branch (.brc) formatted stream.
            </summary>
            <param name="msg">The message to be saved.</param>
            <param name="stream">The stream to which the message will be written.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.Load(System.String,System.Func{BeckmanCoulter.Silas.ISilasMessage},System.Func{BeckmanCoulter.Silas.ISilasMessage})">
            <summary>
            Load a SILAS message from a Keeper branch (.brc) formatted file.
            </summary>
            <param name="path">The path to the file that will be loaded.</param>
            <param name="baseMessageFactory">A factory that will be used to create an object that implements ISilasMessage.  This object will be used to hold the message being loaded.  The default is a factory that creates a SilasMessage.</param>
            <param name="subMessageFactory">A factory that will be used to create objects that implement ISilasMessage.  This factory will be used to create ISilasMessages to hold sub-messages.  The default is a factory that creates a SilasMessage.</param>
            <returns>The loaded message.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.Load(System.IO.Stream,System.Func{BeckmanCoulter.Silas.ISilasMessage},System.Func{BeckmanCoulter.Silas.ISilasMessage})">
            <summary>
            Load a SILAS message from a Keeper branch (.brc) formatted stream.
            </summary>
            <param name="stream">The stream that holds the message that will be loaded.</param>
            <param name="baseMessageFactory">A factory that will be used to create an object that implements ISilasMessage.  This object will be used to hold the message being loaded.  The default is a factory that creates a SilasMessage.</param>
            <param name="subMessageFactory">A factory that will be used to create objects that implement ISilasMessage.  This factory will be used to create ISilasMessages to hold sub-messages.  The default is a factory that creates a SilasMessage.</param>
            <returns>The loaded message.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.Clone``1(``0,System.Boolean)">
            <summary>
            Create a duplicate of the given ISilasMessage object, optionally
            performing a deep copy.
            </summary>
            <param name="original">The ISilasMessage to be cloned</param>
            <param name="deepClone">
            If true, recursively create copies of all submessages to be used in the returned 
            copy.  If false, use the same submessage instances that the current object has.
            </param>
            <returns>A copy of the given ISilasMessage.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasMessageHelpers.Clone(BeckmanCoulter.Silas.ISilasMessage,System.Boolean)">
            <summary>
            Create a duplicate of the given ISilasMessage object, optionally
            performing a deep copy.
            </summary>
            <param name="original">The ISilasMessage to be cloned</param>
            <param name="deepClone">
            If true, recursively create copies of all submessages to be used in the returned 
            copy.  If false, use the same submessage instances that the current object has.
            </param>
            <returns>A copy of the given ISilasMessage.</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.#ctor">
            <summary>
            Creates a new SILAS portal using a native (Win32) message pump provider and a 
            generated module name.  The portal is not registered with SILAS until the
            Register method is called.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.#ctor(BeckmanCoulter.Silas.Utility.IMessagePumpProvider)">
            <summary>
            Creates a new SILAS portal with a generated module name and using the given 
            message pump provider.  The portal is not registered with SILAS until the
            Register method is called.
            </summary>
            <param name="messagePumpProvider">The IMessagePumpProvider object that will supply the message pump used to receive SILAS messages.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.#ctor(System.String,BeckmanCoulter.Silas.Utility.IMessagePumpProvider)">
            <summary>
            Create a new SILAS portal with the given module name.  The portal
            is not registered with SILAS until the Register method is called.
            </summary>
            <param name="moduleName"></param>
            <param name="messagePumpProvider"></param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.#ctor(System.String,System.String,BeckmanCoulter.Silas.Utility.IMessagePumpProvider,System.Collections.Generic.IEnumerable{BeckmanCoulter.Silas.ISilasMessageIncomingProcessor},System.Collections.Generic.IEnumerable{BeckmanCoulter.Silas.ISilasMessageOutgoingProcessor})">
            <summary>
            Creates a new SILAS portal with the given module name.  The portal
            is not registered with SILAS until the Register method is called.
            </summary>
            <param name="moduleName">The module name to be used when registering with SILAS.</param>
            <param name="moduleType">The module type to be used when registering with SILAS.</param>
            <param name="messagePumpProvider"></param>
            <param name="incomingProcessors"></param>
            <param name="outgoingProcessors"></param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.ProcessMessageQueue">
            <summary>
            This method runs in its own thread as part of the _messageSendingTask.  It
            processes messages that have been added to the _sendQueue by the Send method,
            creating memory mapped files for the messages and ultimately sending them to
            the SILAS kernel.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Register(System.String,System.String)">
            <summary>
            Register with the SILAS kernel using the given module name and module type.  If
            no module name or module type are given, the module name and type currently assigned
            to the portal will be used.
            </summary>
            <param name="moduleName">The module name to use when registering with SILAS.  If null, the Name property's value will be used.</param>
            <param name="moduleType">The module type to use when registering with SILAS.  If null, the ModuleType property's value will be used.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Unregister">
            <summary>
            Unregister from the SILAS kernel.  This will stop all messages from being
            received and stop any messages from being sent.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.SendRequest(BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Request that the kernel begin sending messages to this portal with the
            given address.
            </summary>
            <param name="address">The SILAS address to begin receiving</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.RequestAll">
            <summary>
            Request that all SILAS messages be received by this portal
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Request(System.String)">
            <summary>
            Request that the given address be received by this portal
            </summary>
            <param name="address">The SILAS address to begin receiving</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Request(BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Request that the given address be received by this portal
            </summary>
            <param name="address">The SILAS address to begin receiving</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Request(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Request that the given addresses be received by this portal
            </summary>
            <param name="addresses">The SILAS addresses to begin receiving</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Request(System.Collections.Generic.IEnumerable{BeckmanCoulter.Silas.Messages.IMessageAddress})">
            <summary>
            Request that the given addresses be received by this portal
            </summary>
            <param name="addresses">The SILAS addresses to begin receiving</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.IgnoreAll">
            <summary>
            Stop receiving any messages from the SILAS kernel but remained
            registered
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Ignore(System.String)">
            <summary>
            Stop receiving messages from the given address
            </summary>
            <param name="address">The SILAS address</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Ignore(BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Stop receiving messages from the given address
            </summary>
            <param name="address">The SILAS address</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Ignore(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Stop receiving messages from the given addresses
            </summary>
            <param name="addresses">The SILAS addresses</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Ignore(System.Collections.Generic.IEnumerable{BeckmanCoulter.Silas.Messages.IMessageAddress})">
            <summary>
            Stop receiving messages from the given addresses
            </summary>
            <param name="addresses">The SILAS addresses</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Send(BeckmanCoulter.Silas.ISilasMessage,System.String)">
            <summary>
            Send the given SILAS message to the given address
            </summary>
            <param name="message">The SILAS message to be sent</param>
            <param name="address">The address to which the message should be sent</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Send(BeckmanCoulter.Silas.ISilasMessage,BeckmanCoulter.Silas.Messages.IMessageAddress)">
            <summary>
            Send the given SILAS message to the given address
            </summary>
            <param name="message">The SILAS message to be sent</param>
            <param name="address">The address to which the message should be sent</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Expect(System.String,System.Int32)">
            <summary>
            Wait for a message from the given address to be received
            </summary>
            <param name="addressedTo">The address to which the message should be addressed</param>
            <param name="timeoutMs">The time to wait for the message</param>
            <returns>The SILAS message received</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Expect(BeckmanCoulter.Silas.Messages.IMessageAddress,System.Int32)">
            <summary>
            Wait for a message from the given address to be received
            </summary>
            <param name="addressedTo">The address to which the message should be addressed</param>
            <param name="timeoutMs">The time to wait for the message</param>
            <returns>The SILAS message received</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Expect(System.String,System.TimeSpan)">
            <summary>
            Wait for a message from the given address to be received
            </summary>
            <param name="addressedTo">The address to which the message should be addressed</param>
            <param name="timeout">The time to wait for the message</param>
            <returns>The SILAS message received</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Expect(BeckmanCoulter.Silas.Messages.IMessageAddress,System.TimeSpan)">
            <summary>
            Wait for a message from the given address to be received
            </summary>
            <param name="addressedTo">The address to which the message should be addressed</param>
            <param name="timeout">The time to wait for the message</param>
            <returns>The SILAS message received</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.SendAndExpect(BeckmanCoulter.Silas.ISilasMessage,System.String,System.String,System.Int32)">
            <summary>
            Send a SILAS message to the given address and wait for a response
            </summary>
            <param name="message">The SILAS message to be sent</param>
            <param name="sendToAddress">The address where the message will be sent</param>
            <param name="expectAddressedTo">The address to which a reply will be sent</param>
            <param name="timeoutMs">The time to wait for a response</param>
            <returns>The response to the sent SILAS message</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.SendAndExpect(BeckmanCoulter.Silas.ISilasMessage,BeckmanCoulter.Silas.Messages.IMessageAddress,BeckmanCoulter.Silas.Messages.IMessageAddress,System.Int32)">
            <summary>
            Send a SILAS message to the given address and wait for a response
            </summary>
            <param name="message">The SILAS message to be sent</param>
            <param name="sendToAddress">The address where the message will be sent</param>
            <param name="expectAddressedTo">The address to which a reply will be sent</param>
            <param name="timeoutMs">The time to wait for a response</param>
            <returns>The response to the sent SILAS message</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.SendAndExpect(BeckmanCoulter.Silas.ISilasMessage,System.String,System.String,System.TimeSpan)">
            <summary>
            Send a SILAS message to the given address and wait for a response
            </summary>
            <param name="message">The SILAS message to be sent</param>
            <param name="sendToAddress">The address where the message will be sent</param>
            <param name="expectAddressedTo">The address to which a reply will be sent</param>
            <param name="timeout">The time to wait for a response</param>
            <returns>The response to the sent SILAS message</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.SendAndExpect(BeckmanCoulter.Silas.ISilasMessage,BeckmanCoulter.Silas.Messages.IMessageAddress,BeckmanCoulter.Silas.Messages.IMessageAddress,System.TimeSpan,System.Func{BeckmanCoulter.Silas.IMessageContext,System.Boolean})">
            <summary>
            Send a SILAS message to the given address and wait for a response
            </summary>
            <param name="message">The SILAS message to be sent</param>
            <param name="sendToAddress">The address where the message will be sent</param>
            <param name="expectAddressedTo">The address to which a reply will be sent</param>
            <param name="timeout">The time to wait for a response</param>
            <param name="condition">A condition that will be used when a message matches the given address to determine if it is the one that should be returned.  Defaults to no condition (first message received is returned).</param>
            <returns>The response to the sent SILAS message</returns>
            <exception cref="T:System.TimeoutException"/>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.SendAndObserve(BeckmanCoulter.Silas.ISilasMessage,BeckmanCoulter.Silas.Messages.IMessageAddress,BeckmanCoulter.Silas.Messages.IMessageAddress,System.TimeSpan,System.Func{BeckmanCoulter.Silas.IMessageContext,System.Boolean})">
            <summary>
            Send a message and return an IObservable that can be used to receive responses.
            </summary>
            <param name="message">The message that will be sent</param>
            <param name="requestAddress">The address to which the message will be sent</param>
            <param name="replyAddress">The address of messages that will be passed through the returned observable</param>
            <param name="timeout">The amount of time for which the returned IObservable should listen for replies.  The observable throws a TimeoutException if this time is exceeded.</param>
            <returns>
            An observable which contains all messages matching the replyAddress from the time the message was sent.
            Note that each time an observer subscribes to this IObservable, all the messages will be processed by the
            observer (not just ones received from the time the observer subscribes).
            </returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.Dispose">
            <summary>
            Release all resources used by the portal.  The portal will
            not be usable once this method completes.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.GetKernel">
            <summary>
            Retrieve an instance of the SILAS kernel as a COM object.  This object can be used to register
            with SILAS, unregister, and request/ignore messages from specified addresses.  The returned
            object should be released via ReleaseKernel once it is no longer needed.
            </summary>
            <returns>The SILAS kernel COM object</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.ReleaseKernel(System.Object@)">
            <summary>
            Release the SILAS kernel COM object.
            </summary>
            <param name="kernel">The SILAS kernel COM object to be released.  It is a ref parameter</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.SendToKernel(System.Int32,System.String)">
            <summary>
            Send a Window message to the kernel.  This is typically only done when the portal
            needs to notify the kernel that a message is ready to be sent or if the portal wants
            to register/unregister.
            </summary>
            <param name="dataType"></param>
            <param name="data"></param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.SendReturnReceipt(BeckmanCoulter.Silas.Messages.IMessageAddress,System.Byte[])">
            <summary>
            Send a message to the SILAS kernel to notify it that a return receipt should be sent
            for the given message (via its memory mapped file name).
            </summary>
            <param name="originalAddress">The address to which the original message was sent (the message requesting a receipt)</param>
            <param name="rawMessage">The message that may include the a %Return value indicating that a receipt message should be returned.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.WndProc(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.Boolean@)">
            <summary>
            When the message pump provider receives a message, it will forward it to this
            method to be processed.  We are only interested in WM_COPYDATA messages since
            this is the message the kernel will send to indicate that a new message is
            available to be processed.
            </summary>
            <param name="hwnd">The target of the message</param>
            <param name="msg">The msg type/ID</param>
            <param name="wparam">Unused</param>
            <param name="lparam">A pointer to the struct that holds information about the "copy" operation</param>
            <param name="handled">If the method handles the message, this will be set to true</param>
            <returns>Unused</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.ParseMapInfo(System.String,System.String@,System.UInt32@)">
            <summary>
            Parse the string received by the WndProc method to extract the target address for the
            message being received as well as information about the memory mapped file where the
            message is being temporarily stored.
            </summary>
            <param name="mapInfo"></param>
            <param name="mapFileName"></param>
            <param name="mapFileSize"></param>
            <returns></returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.LoadMessageFromMapFile(System.String,System.UInt32,BeckmanCoulter.Silas.Messages.IMessageAddress,System.Byte[]@)">
            <summary>
            Given information about the memory mapped file that holds a SILAS message, read
            in the SILAS message
            </summary>
            <param name="mapFileName">The name of the memory mapped file that holds the SILAS message</param>
            <param name="size">The size of the memory mapped file</param>
            <param name="address">The address to which the SILAS message is being sent</param>
            <param name="rawMessage">The serialized SILAS message</param>
            <returns>A Lazy object that can be used to obtain the deserialized SILAS message</returns>
        </member>
        <member name="M:BeckmanCoulter.Silas.SilasPortal.SaveMessageToMapFile(BeckmanCoulter.Silas.Messages.IMessageAddress,BeckmanCoulter.Silas.ISilasMessage,System.String@)">
            <summary>
            Save the given SILAS message to a new memory mapped file
            </summary>
            <param name="address">The address to which the SILAS message is being sent</param>
            <param name="message">The SILAS message being sent</param>
            <param name="mapInfo">Information about the memory mapped file in which the SILAS message has been stored</param>
            <returns></returns>
        </member>
        <member name="T:System.Threading.Tasks.Schedulers.StaTaskScheduler">
            <summary>Provides a scheduler that uses STA threads.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Schedulers.StaTaskScheduler._tasks">
            <summary>Stores the queued tasks to be executed by our pool of STA threads.</summary>
        </member>
        <member name="F:System.Threading.Tasks.Schedulers.StaTaskScheduler._threads">
            <summary>The STA threads used by the scheduler.</summary>
        </member>
        <member name="M:System.Threading.Tasks.Schedulers.StaTaskScheduler.#ctor(System.Int32)">
            <summary>Initializes a new instance of the StaTaskScheduler class with the specified concurrency level.</summary>
            <param name="numberOfThreads">The number of threads that should be created and used by this scheduler.</param>
        </member>
        <member name="M:System.Threading.Tasks.Schedulers.StaTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a Task to be executed by this scheduler.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:System.Threading.Tasks.Schedulers.StaTaskScheduler.GetScheduledTasks">
            <summary>Provides a list of the scheduled tasks for the debugger to consume.</summary>
            <returns>An enumerable of all tasks currently scheduled.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Schedulers.StaTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Determines whether a Task may be inlined.</summary>
            <param name="task">The task to be executed.</param>
            <param name="taskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was successfully inlined; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Schedulers.StaTaskScheduler.Dispose">
            <summary>
            Cleans up the scheduler by indicating that no more tasks will be queued.
            This method blocks until all threads successfully shutdown.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Schedulers.StaTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level supported by this scheduler.</summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.Unmanaged.DestroyWindow(System.IntPtr)">
            <summary>
            <para>The DestroyWindow function destroys the specified window. The function sends WM_DESTROY and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus from it. The function also destroys the window's menu, flushes the thread message queue, destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if the window is at the top of the viewer chain).</para>
            <para>If the specified window is a parent or owner window, DestroyWindow automatically destroys the associated child or owned windows when it destroys the parent or owner window. The function first destroys child or owned windows, and then it destroys the parent or owner window.</para>
            <para>DestroyWindow also destroys modeless dialog boxes created by the CreateDialog function.</para>
            </summary>
            <param name="hwnd">Handle to the window to be destroyed.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.ByteAlignClient">
            <summary>Aligns the window's client area on a byte boundary (in the x direction). This style affects the width of the window and its horizontal placement on the display.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.ByteAlignWindow">
            <summary>Aligns the window on a byte boundary (in the x direction). This style affects the width of the window and its horizontal placement on the display.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.ClassDC">
            <summary>
            Allocates one device context to be shared by all windows in the class.
            Because window classes are process specific, it is possible for multiple threads of an application to create a window of the same class.
            It is also possible for the threads to attempt to use the device context simultaneously. When this happens, the system allows only one thread to successfully finish its drawing operation.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.DoubleClicks">
            <summary>Sends a double-click message to the window procedure when the user double-clicks the mouse while the cursor is within a window belonging to the class.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.DropShadow">
            <summary>
            Enables the drop shadow effect on a window. The effect is turned on and off through SPI_SETDROPSHADOW.
            Typically, this is enabled for small, short-lived windows such as menus to emphasize their Z order relationship to other windows.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.GlobalClass">
            <summary>Indicates that the window class is an application global class. For more information, see the "Application Global Classes" section of About Window Classes.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.HorizontalRedraw">
            <summary>Redraws the entire window if a movement or size adjustment changes the width of the client area.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.NoClose">
            <summary>Disables Close on the window menu.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.OwnDC">
            <summary>Allocates a unique device context for each window in the class.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.ParentDC">
            <summary>
            Sets the clipping rectangle of the child window to that of the parent window so that the child can draw on the parent.
            A window with the CS_PARENTDC style bit receives a regular device context from the system's cache of device contexts.
            It does not give the child the parent's device context or device context settings. Specifying CS_PARENTDC enhances an application's performance.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.SaveBits">
            <summary>
            Saves, as a bitmap, the portion of the screen image obscured by a window of this class.
            When the window is removed, the system uses the saved bitmap to restore the screen image, including other windows that were obscured.
            Therefore, the system does not send WM_PAINT messages to windows that were obscured if the memory used by the bitmap has not been discarded and if other screen actions have not invalidated the stored image.
            This style is useful for small windows (for example, menus or dialog boxes) that are displayed briefly and then removed before other screen activity takes place.
            This style increases the time required to display the window, because the system must first allocate memory to store the bitmap.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.ClassStyles.VerticalRedraw">
            <summary>Redraws the entire window if a movement or size adjustment changes the height of the client area.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_ACCEPTFILES">
            <summary>
            Specifies that a window created with this style accepts drag-drop files.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_APPWINDOW">
            <summary>
            Forces a top-level window onto the taskbar when the window is visible.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_CLIENTEDGE">
            <summary>
            Specifies that a window has a border with a sunken edge.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_COMPOSITED">
            <summary>
            Windows XP: Paints all descendants of a window in bottom-to-top painting order using double-buffering. For more information, see Remarks. This cannot be used if the window has a class style of either CS_OWNDC or CS_CLASSDC. 
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_CONTEXTHELP">
            <summary>
            Includes a question mark in the title bar of the window. When the user clicks the question mark, the cursor changes to a question mark with a pointer. If the user then clicks a child window, the child receives a WM_HELP message. The child window should pass the message to the parent window procedure, which should call the WinHelp function using the HELP_WM_HELP command. The Help application displays a pop-up window that typically contains help for the child window.
            WS_EX_CONTEXTHELP cannot be used with the WS_MAXIMIZEBOX or WS_MINIMIZEBOX styles.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_CONTROLPARENT">
            <summary>
            The window itself contains child windows that should take part in dialog box navigation. If this style is specified, the dialog manager recurses into children of this window when performing navigation operations such as handling the TAB key, an arrow key, or a keyboard mnemonic.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_DLGMODALFRAME">
            <summary>
            Creates a window that has a double border; the window can, optionally, be created with a title bar by specifying the WS_CAPTION style in the dwStyle parameter.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_LAYERED">
            <summary>
            Windows 2000/XP: Creates a layered window. Note that this cannot be used for child windows. Also, this cannot be used if the window has a class style of either CS_OWNDC or CS_CLASSDC. 
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_LAYOUTRTL">
            <summary>
            Arabic and Hebrew versions of Windows 98/Me, Windows 2000/XP: Creates a window whose horizontal origin is on the right edge. Increasing horizontal values advance to the left. 
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_LEFT">
            <summary>
            Creates a window that has generic left-aligned properties. This is the default.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_LEFTSCROLLBAR">
            <summary>
            If the shell language is Hebrew, Arabic, or another language that supports reading order alignment, the vertical scroll bar (if present) is to the left of the client area. For other languages, the style is ignored.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_LTRREADING">
            <summary>
            The window text is displayed using left-to-right reading-order properties. This is the default.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_MDICHILD">
            <summary>
            Creates a multiple-document interface (MDI) child window.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_NOACTIVATE">
            <summary>
            Windows 2000/XP: A top-level window created with this style does not become the foreground window when the user clicks it. The system does not bring this window to the foreground when the user minimizes or closes the foreground window. 
            To activate the window, use the SetActiveWindow or SetForegroundWindow function.
            The window does not appear on the taskbar by default. To force the window to appear on the taskbar, use the WS_EX_APPWINDOW style.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_NOINHERITLAYOUT">
            <summary>
            Windows 2000/XP: A window created with this style does not pass its window layout to its child windows.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_NOPARENTNOTIFY">
            <summary>
            Specifies that a child window created with this style does not send the WM_PARENTNOTIFY message to its parent window when it is created or destroyed.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_OVERLAPPEDWINDOW">
            <summary>
            Combines the WS_EX_CLIENTEDGE and WS_EX_WINDOWEDGE styles.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_PALETTEWINDOW">
            <summary>
            Combines the WS_EX_WINDOWEDGE, WS_EX_TOOLWINDOW, and WS_EX_TOPMOST styles.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_RIGHT">
            <summary>
            The window has generic "right-aligned" properties. This depends on the window class. This style has an effect only if the shell language is Hebrew, Arabic, or another language that supports reading-order alignment; otherwise, the style is ignored.
            Using the WS_EX_RIGHT style for static or edit controls has the same effect as using the SS_RIGHT or ES_RIGHT style, respectively. Using this style with button controls has the same effect as using BS_RIGHT and BS_RIGHTBUTTON styles.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_RIGHTSCROLLBAR">
            <summary>
            Vertical scroll bar (if present) is to the right of the client area. This is the default.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_RTLREADING">
            <summary>
            If the shell language is Hebrew, Arabic, or another language that supports reading-order alignment, the window text is displayed using right-to-left reading-order properties. For other languages, the style is ignored.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_STATICEDGE">
            <summary>
            Creates a window with a three-dimensional border style intended to be used for items that do not accept user input.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_TOOLWINDOW">
            <summary>
            Creates a tool window; that is, a window intended to be used as a floating toolbar. A tool window has a title bar that is shorter than a normal title bar, and the window title is drawn using a smaller font. A tool window does not appear in the taskbar or in the dialog that appears when the user presses ALT+TAB. If a tool window has a system menu, its icon is not displayed on the title bar. However, you can display the system menu by right-clicking or by typing ALT+SPACE. 
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_TOPMOST">
            <summary>
            Specifies that a window created with this style should be placed above all non-topmost windows and should stay above them, even when the window is deactivated. To add or remove this style, use the SetWindowPos function.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_TRANSPARENT">
            <summary>
            Specifies that a window created with this style should not be painted until siblings beneath the window (that were created by the same thread) have been painted. The window appears transparent because the bits of underlying sibling windows have already been painted.
            To achieve transparency without these restrictions, use the SetWindowRgn function.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStylesEx.WS_EX_WINDOWEDGE">
            <summary>
            Specifies that a window has a border with a raised edge.
            </summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Utility.WindowStyles">
            <summary>
            Window Styles.
            The following styles can be specified wherever a window style is required. After the control has been created, these styles cannot be modified, except as noted.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_BORDER">
            <summary>The window has a thin-line border.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_CAPTION">
            <summary>The window has a title bar (includes the WS_BORDER style).</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_CHILD">
            <summary>The window is a child window. A window with this style cannot have a menu bar. This style cannot be used with the WS_POPUP style.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_CLIPCHILDREN">
            <summary>Excludes the area occupied by child windows when drawing occurs within the parent window. This style is used when creating the parent window.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_CLIPSIBLINGS">
            <summary>
            Clips child windows relative to each other; that is, when a particular child window receives a WM_PAINT message, the WS_CLIPSIBLINGS style clips all other overlapping child windows out of the region of the child window to be updated.
            If WS_CLIPSIBLINGS is not specified and child windows overlap, it is possible, when drawing within the client area of a child window, to draw within the client area of a neighboring child window.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_DISABLED">
            <summary>The window is initially disabled. A disabled window cannot receive input from the user. To change this after a window has been created, use the EnableWindow function.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_DLGFRAME">
            <summary>The window has a border of a style typically used with dialog boxes. A window with this style cannot have a title bar.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_GROUP">
            <summary>
            The window is the first control of a group of controls. The group consists of this first control and all controls defined after it, up to the next control with the WS_GROUP style.
            The first control in each group usually has the WS_TABSTOP style so that the user can move from group to group. The user can subsequently change the keyboard focus from one control in the group to the next control in the group by using the direction keys.
            You can turn this style on and off to change dialog box navigation. To change this style after a window has been created, use the SetWindowLong function.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_HSCROLL">
            <summary>The window has a horizontal scroll bar.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_MAXIMIZE">
            <summary>The window is initially maximized.</summary> 
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_MAXIMIZEBOX">
            <summary>The window has a maximize button. Cannot be combined with the WS_EX_CONTEXTHELP style. The WS_SYSMENU style must also be specified.</summary> 
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_MINIMIZE">
            <summary>The window is initially minimized.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_MINIMIZEBOX">
            <summary>The window has a minimize button. Cannot be combined with the WS_EX_CONTEXTHELP style. The WS_SYSMENU style must also be specified.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_OVERLAPPED">
            <summary>The window is an overlapped window. An overlapped window has a title bar and a border.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_OVERLAPPEDWINDOW">
            <summary>The window is an overlapped window.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_POPUP">
            <summary>The window is a pop-up window. This style cannot be used with the WS_CHILD style.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_POPUPWINDOW">
            <summary>The window is a pop-up window. The WS_CAPTION and WS_POPUPWINDOW styles must be combined to make the window menu visible.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_SIZEFRAME">
            <summary>The window has a sizing border.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_SYSMENU">
            <summary>The window has a window menu on its title bar. The WS_CAPTION style must also be specified.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_TABSTOP">
            <summary>
            The window is a control that can receive the keyboard focus when the user presses the TAB key.
            Pressing the TAB key changes the keyboard focus to the next control with the WS_TABSTOP style.  
            You can turn this style on and off to change dialog box navigation. To change this style after a window has been created, use the SetWindowLong function.
            For user-created windows and modeless dialogs to work with tab stops, alter the message loop to call the IsDialogMessage function.
            </summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_VISIBLE">
            <summary>The window is initially visible. This style can be turned on and off by using the ShowWindow or SetWindowPos function.</summary>
        </member>
        <member name="F:BeckmanCoulter.Silas.Utility.WindowStyles.WS_VSCROLL">
            <summary>The window has a vertical scroll bar.</summary>
        </member>
        <member name="T:BeckmanCoulter.Silas.Utility.WeakReference`1">
            <summary> 
            Represents a weak reference, which references an object while still allowing   
            that object to be reclaimed by garbage collection.    
            </summary>    
            <typeparam name="T">The type of the object that is referenced.</typeparam>    
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.WeakReference`1.#ctor(`0)">
            <summary>        
            Initializes a new instance of the Minimal.WeakReference{T} class, referencing        
            the specified object.        
            </summary>        
            <param name="target">The object to reference.</param>        
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>        
            Initializes a new instance of the WeakReference{T} class, referencing 
            the specified object and using the specified resurrection tracking. 
            </summary>        
            <param name="target">An object to track.</param> 
            <param name="trackResurrection">Indicates when to stop tracking the object. If true, the object is tracked 
            after finalization; if false, the object is only tracked until finalization.</param> 
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.WeakReference`1.op_Implicit(`0)~BeckmanCoulter.Silas.Utility.WeakReference{`0}">
            <summary> 
            Casts an object of the type T to a weak reference 
            of T. 
            </summary> 
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.WeakReference`1.op_Implicit(BeckmanCoulter.Silas.Utility.WeakReference{`0})~`0">
            <summary> 
            Casts a weak reference to an object of the type the 
            reference represents. 
            </summary> 
        </member>
        <member name="P:BeckmanCoulter.Silas.Utility.WeakReference`1.Target">
            <summary> 
            Gets or sets the object (the target) referenced by the current WeakReference{T} 
            object. 
            </summary> 
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.WpfMessagePumpProvider.Run">
            <summary>
            Starts the message pump on a new thread and returns immediately.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.WpfMessagePumpProvider.Shutdown">
            <summary>
            Completely stops the message pump.  Call Run to start it back up again.
            All delegates passed to AddHook will remain hooked.
            </summary>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.WpfMessagePumpProvider.AddHook(System.Windows.Interop.HwndSourceHook)">
            <summary>
            Provide a delegate that will be called any time a message is received 
            on this pump.
            </summary>
            <param name="hook">The delegate to call whenever a message is received.</param>
        </member>
        <member name="M:BeckmanCoulter.Silas.Utility.WpfMessagePumpProvider.DoEvents">
            <summary>
            Process messages that are waiting in the queue.  This may cause re-entry.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Utility.WpfMessagePumpProvider.Handle">
            <summary>
            The window handle being used to receive messages with this pump.
            </summary>
        </member>
        <member name="P:BeckmanCoulter.Silas.Utility.WpfMessagePumpProvider.Priority">
            <summary>
            The DispatcherPriority that will be used when issuing Invoke and BeginInvoke
            delegates.  Defaults to DispatcherPriority.Normal.
            </summary>
        </member>
    </members>
</doc>
